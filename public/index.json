[
{
	"uri": "https://blueridgeboost.com/pythonbook/docs/copyright/",
	"title": "Copyright Notice",
	"tags": [],
	"description": "",
	"content": "Copyright Notice Copyright (C) 2023, Blue Ridge Boost LLC.\nCopyright (C) 2014, AoPS Incorporated.\nCopyright (C) Peter Wentworth, Jeffrey Elkner, Allen B. Downey and Chris Meyers.\nPermission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with Invariant Sections being Foreword, Foreword-AoPS Edition, Preface, and Contributor List, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled “GNU Free Documentation License”.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/docs/foreword/",
	"title": "Forward",
	"tags": [],
	"description": "",
	"content": "Foreword By David Beazley\nAs an educator, researcher, and book author, I am delighted to see the completion of this book. Python is a fun and extremely easy-to-use programming language that has steadily gained in popularity over the last few years. Developed over ten years ago by Guido van Rossum, Python’s simple syntax and overall feel is largely derived from ABC, a teaching language that was developed in the 1980’s. However, Python was also created to solve real problems and it borrows a wide variety of features from programming languages such as C++, Java, Modula-3, and Scheme. Because of this, one of Python’s most remarkable features is its broad appeal to professional software developers, scientists, researchers, artists, and educators.\nDespite Python’s appeal to many different communities, you may still wonder why Python? or why teach programming with Python? Answering these questions is no simple task—especially when popular opinion is on the side of more masochistic alternatives such as C++ and Java. However, I think the most direct answer is that programming in Python is simply a lot of fun and more productive.\nWhen I teach computer science courses, I want to cover important concepts in addition to making the material interesting and engaging to students. Unfortunately, there is a tendency for introductory programming courses to focus far too much attention on mathematical abstraction and for students to become frustrated with annoying problems related to low-level details of syntax, compilation, and the enforcement of seemingly arcane rules. Although such abstraction and formalism is important to professional software engineers and students who plan to continue their study of computer science, taking such an approach in an introductory course mostly succeeds in making computer science boring. When I teach a course, I don’t want to have a room of uninspired students. I would much rather see them trying to solve interesting problems by exploring different ideas, taking unconventional approaches, breaking the rules, and learning from their mistakes. In doing so, I don’t want to waste half of the semester trying to sort out obscure syntax problems, unintelligible compiler error messages, or the several hundred ways that a program might generate a general protection fault.\nOne of the reasons why I like Python is that it provides a really nice balance between the practical and the conceptual. Since Python is interpreted, beginners can pick up the language and start doing neat things almost immediately without getting lost in the problems of compilation and linking. Furthermore, Python comes with a large library of modules that can be used to do all sorts of tasks ranging from web-programming to graphics. Having such a practical focus is a great way to engage students and it allows them to complete significant projects. However, Python can also serve as an excellent foundation for introducing important computer science concepts. Since Python fully supports procedures and classes, students can be gradually introduced to topics such as procedural abstraction, data structures, and object-oriented programming — all of which are applicable to later courses on Java or C++. Python even borrows a number of features from functional programming languages and can be used to introduce concepts that would be covered in more detail in courses on Scheme and Lisp.\nIn reading Jeffrey’s preface, I am struck by his comments that Python allowed him to see a higher level of success and a lower level of frustration and that he was able to move faster with better results. Although these comments refer to his introductory course, I sometimes use Python for these exact same reasons in advanced graduate level computer science courses at the University of Chicago. In these courses, I am constantly faced with the daunting task of covering a lot of difficult course material in a blistering nine week quarter. Although it is certainly possible for me to inflict a lot of pain and suffering by using a language like C++, I have often found this approach to be counterproductive—especially when the course is about a topic unrelated to just programming. I find that using Python allows me to better focus on the actual topic at hand while allowing students to complete substantial class projects.\nAlthough Python is still a young and evolving language, I believe that it has a bright future in education. This book is an important step in that direction.\nDavid Beazley, University of Chicago, Author of the Python Essential Reference\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/docs/preface/",
	"title": "Preface",
	"tags": [],
	"description": "",
	"content": "Preface By Jeffrey Elkner\nThis book owes its existence to the collaboration made possible by the Internet and the free software movement. Its three authors—a college professor, a high school teacher, and a professional programmer—never met face to face to work on it, but we have been able to collaborate closely, aided by many other folks who have taken the time and energy to send us their feedback.\nWe think this book is a testament to the benefits and future possibilities of this kind of collaboration, the framework for which has been put in place by Richard Stallman and the Free Software Foundation.\nHow and why I came to use Python In 1999, the College Board’s Advanced Placement (AP) Computer Science exam was given in C++ for the first time. As in many high schools throughout the country, the decision to change languages had a direct impact on the computer science curriculum at Yorktown High School in Arlington, Virginia, where I teach. Up to this point, Pascal was the language of instruction in both our first-year and AP courses. In keeping with past practice of giving students two years of exposure to the same language, we made the decision to switch to C++ in the first year course for the 1997-98 school year so that we would be in step with the College Board’s change for the AP course the following year.\nTwo years later, I was convinced that C++ was a poor choice to use for introducing students to computer science. While it is certainly a very powerful programming language, it is also an extremely difficult language to learn and teach. I found myself constantly fighting with C++’s difficult syntax and multiple ways of doing things, and I was losing many students unnecessarily as a result. Convinced there had to be a better language choice for our first-year class, I went looking for an alternative to C++.\nI needed a language that would run on the machines in our GNU/Linux lab as well as on the Windows and Macintosh platforms most students have at home. I wanted it to be free software, so that students could use it at home regardless of their income. I wanted a language that was used by professional programmers, and one that had an active developer community around it. It had to support both procedural and object-oriented programming. And most importantly, it had to be easy to learn and teach. When I investigated the choices with these goals in mind, Python stood out as the best candidate for the job.\nI asked one of Yorktown’s talented students, Matt Ahrens, to give Python a try. In two months he not only learned the language but wrote an application called pyTicket that enabled our staff to report technology problems via the Web. I knew that Matt could not have finished an application of that scale in so short a time in C++, and this accomplishment, combined with Matt’s positive assessment of Python, suggested that Python was the solution I was looking for.\nFinding a textbook Having decided to use Python in both of my introductory computer science classes the following year, the most pressing problem was the lack of an available textbook.\nFree documents came to the rescue. Earlier in the year, Richard Stallman had introduced me to Allen Downey. Both of us had written to Richard expressing an interest in developing free educational materials. Allen had already written a first-year computer science textbook, How to Think Like a Computer Scientist. When I read this book, I knew immediately that I wanted to use it in my class. It was the clearest and most helpful computer science text I had seen. It emphasized the processes of thought involved in programming rather than the features of a particular language. Reading it immediately made me a better teacher.\nHow to Think Like a Computer Scientist was not just an excellent book, but it had been released under the GNU public license, which meant it could be used freely and modified to meet the needs of its user. Once I decided to use Python, it occurred to me that I could translate Allen’s original Java version of the book into the new language. While I would not have been able to write a textbook on my own, having Allen’s book to work from made it possible for me to do so, at the same time demonstrating that the cooperative development model used so well in software could also work for educational materials.\nWorking on this book for the last two years has been rewarding for both my students and me, and my students played a big part in the process. Since I could make instant changes whenever someone found a spelling error or difficult passage, I encouraged them to look for mistakes in the book by giving them a bonus point each time they made a suggestion that resulted in a change in the text. This had the double benefit of encouraging them to read the text more carefully and of getting the text thoroughly reviewed by its most important critics, students using it to learn computer science.\nFor the second half of the book on object-oriented programming, I knew that someone with more real programming experience than I had would be needed to do it right. The book sat in an unfinished state for the better part of a year until the open source community once again provided the needed means for its completion.\nI received an email from Chris Meyers expressing interest in the book. Chris is a professional programmer who started teaching a programming course last year using Python at Lane Community College in Eugene, Oregon. The prospect of teaching the course had led Chris to the book, and he started helping out with it immediately. By the end of the school year he had created a companion project on our Website at http://openbookproject.net called Python for Fun and was working with some of my most advanced students as a master teacher, guiding them beyond where I could take them.\nIntroducing programming with Python The process of translating and using How to Think Like a Computer Scientist for the past two years has confirmed Python’s suitability for teaching beginning students. Python greatly simplifies programming examples and makes important programming ideas easier to teach.\nThe first example from the text illustrates this point. It is the traditional hello, world program, which in the Java version of the book looks like this:\nclass Hello { public static void main (String[] args) { System.out.println (\u0026#34;Hello, world.\u0026#34;); } } in the Python version it becomes:\nprint(\u0026#34;Hello, World!\u0026#34;) Even though this is a trivial example, the advantages of Python stand out. Yorktown’s Computer Science I course has no prerequisites, so many of the students seeing this example are looking at their first program. Some of them are undoubtedly a little nervous, having heard that computer programming is difficult to learn. The Java version has always forced me to choose between two unsatisfying options: either to explain the class Hello, public static void main, String[] args, {, and }, statements and risk confusing or intimidating some of the students right at the start, or to tell them, Just don’t worry about all of that stuff now; we will talk about it later, and risk the same thing. The educational objectives at this point in the course are to introduce students to the idea of a programming statement and to get them to write their first program, thereby introducing them to the programming environment. The Python program has exactly what is needed to do these things, and nothing more.\nComparing the explanatory text of the program in each version of the book further illustrates what this means to the beginning student. There are seven paragraphs of explanation of Hello, world! in the Java version; in the Python version, there are only a few sentences. More importantly, the missing six paragraphs do not deal with the big ideas in computer programming but with the minutia of Java syntax. I found this same thing happening throughout the book. Whole paragraphs simply disappear from the Python version of the text because Python’s much clearer syntax renders them unnecessary.\nUsing a very high-level language like Python allows a teacher to postpone talking about low-level details of the machine until students have the background that they need to better make sense of the details. It thus creates the ability to put first things first pedagogically. One of the best examples of this is the way in which Python handles variables. In Java a variable is a name for a place that holds a value if it is a built-in type, and a reference to an object if it is not. Explaining this distinction requires a discussion of how the computer stores data. Thus, the idea of a variable is bound up with the hardware of the machine. The powerful and fundamental concept of a variable is already difficult enough for beginning students (in both computer science and algebra). Bytes and addresses do not help the matter. In Python a variable is a name that refers to a thing. This is a far more intuitive concept for beginning students and is much closer to the meaning of variable that they learned in their math courses. I had much less difficulty teaching variables this year than I did in the past, and I spent less time helping students with problems using them.\nAnother example of how Python aids in the teaching and learning of programming is in its syntax for functions. My students have always had a great deal of difficulty understanding functions. The main problem centers around the difference between a function definition and a function call, and the related distinction between a parameter and an argument. Python comes to the rescue with syntax that is nothing short of beautiful. Function definitions begin with the keyword def, so I simply tell my students, When you define a function, begin with def, followed by the name of the function that you are defining; when you call a function, simply call (type) out its name. Parameters go with definitions; arguments go with calls. There are no return types, parameter types, or reference and value parameters to get in the way, so I am now able to teach functions in less than half the time that it previously took me, with better comprehension.\nUsing Python improved the effectiveness of our computer science program for all students. I saw a higher general level of success and a lower level of frustration than I experienced teaching with either C++ or Java. I moved faster with better results. More students left the course with the ability to create meaningful programs and with the positive attitude toward the experience of programming that this engenders.\nBuilding a community I have received email from all over the globe from people using this book to learn or to teach programming. A user community has begun to emerge, and many people have been contributing to the project by sending in materials for the companion Website at http://openbookproject.net/pybiblio.\nWith the continued growth of Python, I expect the growth in the user community to continue and accelerate. The emergence of this user community and the possibility it suggests for similar collaboration among educators have been the most exciting parts of working on this project for me. By working together, we can increase the quality of materials available for our use and save valuable time. I invite you to join our community and look forward to hearing from you. Please write to me at\njeff@elkner.net\nJeffrey Elkner\nGovernor’s Career and Technical Academy in Arlington\nArlington, Virginia\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/docs/contrib/",
	"title": "Contributor List",
	"tags": [],
	"description": "",
	"content": "Contributor List To paraphrase the philosophy of the Free Software Foundation, this book is free like free speech, but not necessarily free like free pizza. It came about because of a collaboration that would not have been possible without the GNU Free Documentation License. So we would like to thank the Free Software Foundation for developing this license and, of course, making it available to us.\nWe would also like to thank the more than 100 sharp-eyed and thoughtful readers who have sent us suggestions and corrections over the past few years. In the spirit of free software, we decided to express our gratitude in the form of a contributor list. Unfortunately, this list is not complete, but we are doing our best to keep it up to date. It was also getting too large to include everyone who sends in a typo or two. You have our gratitude, and you have the personal satisfaction of making a book you found useful better for you and everyone else who uses it. New additions to the list for the 2nd edition will be those who have made on-going contributions.\nIf you have a chance to look through the list, you should realize that each person here has spared you and all subsequent readers from the confusion of a technical error or a less-than-transparent explanation, just by sending us a note.\nImpossible as it may seem after so many corrections, there may still be errors in this book. If you should stumble across one, we hope you will take a minute to contact us. The email address (for the Python 3 version of the book) is p.wentworth@ru.ac.za . Substantial changes made due to your suggestions will add you to the next version of the contributor list (unless you ask to be omitted). Thank you!\nSecond Edition An email from Mike MacHenry set me straight on tail recursion. He not only pointed out an error in the presentation, but suggested how to correct it.\nIt wasn’t until 5th Grade student Owen Davies came to me in a Saturday morning Python enrichment class and said he wanted to write the card game, Gin Rummy, in Python that I finally knew what I wanted to use as the case study for the object oriented programming chapters.\nA special thanks to pioneering students in Jeff’s Python Programming class at GCTAA during the 2009-2010 school year: Safath Ahmed, Howard Batiste, Louis Elkner-Alfaro, and Rachel Hancock. Your continual and thoughtfull feedback led to changes in most of the chapters of the book. You set the standard for the active and engaged learners that will help make the new Governor’s Academy what it is to become. Thanks to you this is truly a student tested text.\nThanks in a similar vein to the students in Jeff’s Computer Science class at the HB-Woodlawn program during the 2007-2008 school year: James Crowley, Joshua Eddy, Eric Larson, Brian McGrail, and Iliana Vazuka.\nAmmar Nabulsi sent in numerous corrections from Chapters 1 and 2.\nAldric Giacomoni pointed out an error in our definition of the Fibonacci sequence in Chapter 5.\nRoger Sperberg sent in several spelling corrections and pointed out a twisted piece of logic in Chapter 3.\nAdele Goldberg sat down with Jeff at PyCon 2007 and gave him a list of suggestions and corrections from throughout the book.\nBen Bruno sent in corrections for chapters 4, 5, 6, and 7.\nCarl LaCombe pointed out that we incorrectly used the term commutative in chapter 6 where symmetric was the correct term.\nAlessandro Montanile sent in corrections for errors in the code examples and text in chapters 3, 12, 15, 17, 18, 19, and 20.\nEmanuele Rusconi found errors in chapters 4, 8, and 15.\nMichael Vogt reported an indentation error in an example in chapter 6, and sent in a suggestion for improving the clarity of the shell vs. script section in chapter 1.\nFirst Edition Lloyd Hugh Allen sent in a correction to Section 8.4. Yvon Boulianne sent in a correction of a semantic error in Chapter 5. Fred Bremmer submitted a correction in Section 2.1. Jonah Cohen wrote the Perl scripts to convert the LaTeX source for this book into beautiful HTML. Michael Conlon sent in a grammar correction in Chapter 2 and an improvement in style in Chapter 1, and he initiated discussion on the technical aspects of interpreters. Benoit Girard sent in a correction to a humorous mistake in Section 5.6. Courtney Gleason and Katherine Smith wrote horsebet.py, which was used as a case study in an earlier version of the book. Their program can now be found on the website. Lee Harr submitted more corrections than we have room to list here, and indeed he should be listed as one of the principal editors of the text. James Kaylin is a student using the text. He has submitted numerous corrections. David Kershaw fixed the broken catTwice function in Section 3.10. Eddie Lam has sent in numerous corrections to Chapters 1, 2, and 3. He also fixed the Makefile so that it creates an index the first time it is run and helped us set up a versioning scheme. Man-Yong Lee sent in a correction to the example code in Section 2.4. David Mayo pointed out that the word unconsciously in Chapter 1 needed to be changed to subconsciously . Chris McAloon sent in several corrections to Sections 3.9 and 3.10. Matthew J. Moelter has been a long-time contributor who sent in numerous corrections and suggestions to the book. Simon Dicon Montford reported a missing function definition and several typos in Chapter 3. He also found errors in the increment function in Chapter 13. John Ouzts corrected the definition of return value in Chapter 3. Kevin Parks sent in valuable comments and suggestions as to how to improve the distribution of the book. David Pool sent in a typo in the glossary of Chapter 1, as well as kind words of encouragement. Michael Schmitt sent in a correction to the chapter on files and exceptions. Robin Shaw pointed out an error in Section 13.1, where the printTime function was used in an example without being defined. Paul Sleigh found an error in Chapter 7 and a bug in Jonah Cohen’s Perl script that generates HTML from LaTeX. Craig T. Snydal is testing the text in a course at Drew University. He has contributed several valuable suggestions and corrections. Ian Thomas and his students are using the text in a programming course. They are the first ones to test the chapters in the latter half of the book, and they have make numerous corrections and suggestions. Keith Verheyden sent in a correction in Chapter 3. Peter Winstanley let us know about a longstanding error in our Latin in Chapter 3. Chris Wrobel made corrections to the code in the chapter on file I/O and exceptions. Moshe Zadka has made invaluable contributions to this project. In addition to writing the first draft of the chapter on Dictionaries, he provided continual guidance in the early stages of the book. Christoph Zwerschke sent several corrections and pedagogic suggestions, and explained the difference between gleich and selbe. James Mayer sent us a whole slew of spelling and typographical errors, including two in the contributor list. Hayden McAfee caught a potentially confusing inconsistency between two examples. Angel Arnal is part of an international team of translators working on the Spanish version of the text. He has also found several errors in the English version. Tauhidul Hoque and Lex Berezhny created the illustrations in Chapter 1 and improved many of the other illustrations. Dr. Michele Alzetta caught an error in Chapter 8 and sent some interesting pedagogic comments and suggestions about Fibonacci and Old Maid. Andy Mitchell caught a typo in Chapter 1 and a broken example in Chapter 2. Kalin Harvey suggested a clarification in Chapter 7 and caught some typos. Christopher P. Smith caught several typos and is helping us prepare to update the book for Python 2.2. David Hutchins caught a typo in the Foreword. Gregor Lingl is teaching Python at a high school in Vienna, Austria. He is working on a German translation of the book, and he caught a couple of bad errors in Chapter 5. Julie Peters caught a typo in the Preface. "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/docs/chapter01/",
	"title": "The way of program",
	"tags": [],
	"description": "",
	"content": "The way of the program The goal of this book is to teach you to think like a computer scientist. As computer scientists, we will combine some of the best features of mathematics, engineering, and natural science. Like mathematicians, we will use formal languages to communicate our ideas. Like engineers, we will design complex systems, assembling components into systems and evaluating tradeoffs among alternatives. Like scientists, we will observe the behavior of complex systems, form hypotheses, and test predictions.\nThe single most important skill for a computer scientist is problem solving. Problem solving is a skill that involves formulating problems, thinking creatively about solutions, and expressing a solution clearly and accurately. As it turns out, the process of learning to program is an excellent opportunity to practice problem-solving skills. That’s why this chapter is called The way of the program.\nThe Python programming language The programming language you will be learning is Python. Python is an example of a high-level language; other high-level languages you might have heard of are C++, PHP, Pascal, C#, and Java.\nAs you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Loosely speaking, computers can only execute programs written in low-level languages. Thus, programs written in a high-level language have to be translated into something more suitable before they can run.\nAlmost all programs are written in high-level languages because of their advantages. It is much easier to program in a high-level language so programs take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications.\nThe engine that translates and runs Python is called the Python Interpreter: There are two ways to use it: immediate mode and script mode. In immediate mode, which we also call shell mode, you type Python expressions into the Python interpreter window (which is also called the shell), and the interpreter immediately shows the result.\nIn AoPS classes, we will use the IDLE application that comes built-in with most Python installations. In IDLE, the Python interpreter window is labeled Python Shell.\nInstructions for installing Python on your computer are including in the Course Introduction document on the AoPS class homepage, and are also posted on the class message board. When you start up IDLE on your computer, it should look something like this:\nThe \u0026gt;\u0026gt; is called the Python prompt. The interpreter uses the prompt to indicate that it is ready for instructions. We typed 2+2, and the interpreter evaluated our expression, and replied 4, and on the next line it gave a new prompt, indicating that it is ready for more.\nAlternatively, you can write a program in a file and use the interpreter to run the lines of code in the file. Such a file is called a script. Scripts have the advantage that they can be saved, printed, and so on. A Python script is often called a module.\nFor example, we can created a file named firstprogram.py using IDLE. By convention, files that contain Python programs have names that end with .py. To do this, select “New File” or “New Window” from the File menu of IDLE, and then type the following two lines into the new window that appears:\nTo run the program, we can select the “Run Module” or “Run Program” option from the “Run” menu of IDLE (or alternatively you can press the F5 key). IDLE will ask you to save your program before it can run it. Save it using the name firstprogram.py. Then your program will run, and it should look something like the screenshot below:\nNotice that the program always runs in the Shell window.\nDon’t worry, most programs are more interesting than this one.\nWorking directly in the interpreter is convenient for testing short bits of code because you get immediate feedback. Think of it as scratch paper used to help you work out problems. Anything longer than a few lines should be put into a script.\nThere’s a third way that you can run Python using this ebook. In many places in this ebook, we’ll have a Python interpreter built directly into the text. For example, our program from above can appear directly in the book as shown below:\nprint(\u0026#39;My first program adds two numbers.\u0026#39;) print(2+3) If you click the “Run” button, the program will run and you’ll see its output above directly in the ebook. You can also edit the code directly in the window above. If you click the “Reset” button (or refresh your browser window), the code will return to what it originally was (that is, any edits that you’ve made will be removed.) The little numbers to the left are line numbers, and you don’t type them in. They appear automatically in our ebook, so that it’s easier for us to discuss our program. For example, we can say “line 1 of our program prints a sentence”.\nWhat is a program? A program is a sequence of instructions that specifies how to perform a computation. The computation might be something mathematical, such as solving a system of equations or finding the roots of a polynomial, but it can also be a symbolic computation, such as searching and replacing text in a document.\nThe details look different in different languages, but a few basic instructions appear in just about every language:\ninput. Get data from the keyboard, a file, or some other device. output. Display data on the screen or send data to a file or other device. math. Perform basic mathematical operations like addition and multiplication. conditional execution. Check for certain conditions and execute the appropriate sequence of statements. repetition. Perform some action repeatedly, usually with some variation. Believe it or not, that’s pretty much all there is to it. Every program you’ve ever used, no matter how complicated, is made up of instructions that look more or less like these. Thus, we can describe programming as the process of breaking a large, complex task into smaller and smaller subtasks until the subtasks are simple enough to be performed with sequences of these basic instructions.\nThat may be a little vague, but we will come back to this topic later when we talk about algorithms.\nWhat is debugging? Programming is a complex process, and because it is done by human beings, it often leads to errors. Programming errors are called bugs and the process of tracking them down and correcting them is called debugging. Use of the term bug to describe small engineering difficulties dates back to at least 1889, when Thomas Edison had a bug with his phonograph.\nThree kinds of errors can occur in a program: syntax errors, runtime errors, and semantic errors. It is useful to distinguish between them in order to track them down more quickly.\nSyntax errors Python can only execute a program if the program is syntactically correct; otherwise, the process fails and returns an error message. Syntax refers to the structure of a program and the rules about that structure. For example, in English, a sentence must begin with a capital letter and end with a period. this sentence contains a syntax error. So does this one\nFor most humans, a few syntax errors are not a significant problem, which is why we can read the above sentences and still figure out what they mean. Python is not so forgiving. If there is a single syntax error anywhere in your program, Python will display an error message and quit, and you will not be able to run your program. During the first few weeks of your programming career, you will probably spend a lot of time tracking down syntax errors. As you gain experience, though, you will make fewer errors and find them faster.\nRuntime errors The second type of error is a runtime error, so called because the error does not appear until you run the program. These errors are also called exceptions because they usually indicate that something exceptional (and bad) has happened.\nRuntime errors are rare in the simple programs you will see in the first few chapters, so it might be a while before you encounter one.\nSemantic errors The third type of error is the semantic error. If there is a semantic error in your program, it will run successfully, in the sense that the computer will not generate any error messages, but it will not do the right thing. It will do something else. Specifically, it will do what you told it to do.\nThe problem is that the program you wrote is not the program you wanted to write. The meaning of the program (its semantics) is wrong. Identifying semantic errors can be tricky because it requires you to work backward by looking at the output of the program and trying to figure out what it is doing.\nExperimental debugging One of the most important skills you will acquire is debugging. Although it can be frustrating, debugging is one of the most intellectually rich, challenging, and interesting parts of programming.\nIn some ways, debugging is like detective work. You are confronted with clues, and you have to infer the processes and events that led to the results you see.\nDebugging is also like an experimental science. Once you have an idea what is going wrong, you modify your program and try again. If your hypothesis was correct, then you can predict the result of the modification, and you take a step closer to a working program. If your hypothesis was wrong, you have to come up with a new one. As Sherlock Holmes pointed out: When you have eliminated the impossible, whatever remains, however improbable, must be the truth. (A. Conan Doyle, The Sign of Four)\nFor some people, programming and debugging are the same thing. That is, programming is the process of gradually debugging a program until it does what you want. The idea is that you should start with a program that does something and make small modifications, debugging them as you go, so that you always have a working program.\nLater chapters will make more suggestions about debugging and other programming practices.\nFormal and natural languages Natural languages are the languages that people speak, such as English, Spanish, and French. They were not designed by people (although people try to impose some order on them); they evolved naturally.\nFormal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. And most importantly:\nProgramming languages are formal languages that have been designed to express computations. Formal languages tend to have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6 is not. H~2~O is a syntactically correct chemical name, but ~2~Zz is not.\nSyntax rules come in two flavors, pertaining to tokens and structure. Tokens are the basic elements of the language, such as words, numbers, parentheses, commas, and so on. In Python, a statement like\nprint(\u0026quot;Happy New Year\u0026quot;)\nhas 6 tokens: a function name, an open parenthesis (round bracket), a string, a comma, a number, and a close parenthesis.\nIt is possible to make errors in the way one constructs tokens. One of the problems with 3=+6 is that ```$`````` is not a legal token in mathematics (at least as far as we know). Similarly, ~2 Zz is not a legal token in chemistry notation because there is no element with the abbreviation Zz.\nThe second type of syntax rule pertains to the structure of a statement— that is, the way the tokens are arranged. The statement ```3=+6`````` is structurally illegal because you can’t place a plus sign immediately after an equal sign. Similarly, molecular formulas have to have subscripts after the element name, not before. And in our Python example, if we omitted the comma, or if we changed the two parentheses around to say\nprint)\u0026#34;Happy New Year!\u0026#34;( our statement would still have six legal and valid tokens, but the structure is illegal.\nWhen you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is (although in a natural language you do this subconsciously). This process is called parsing.\nFor example, when you hear the sentence, “The other shoe fell”, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence.\nAlthough formal and natural languages have many features in common — tokens, structure, syntax, and semantics — there are many differences:\nambiguity Natural languages are full of ambiguity, which people deal with by using contextual clues and other information. Formal languages are designed to be nearly or completely unambiguous, which means that any statement has exactly one meaning, regardless of context.\nredundancy In order to make up for ambiguity and reduce misunderstandings, natural languages employ lots of redundancy. As a result, they are often verbose. Formal languages are less redundant and more concise.\nliteralness Formal languages mean exactly what they say. On the other hand, natural languages are full of idiom and metaphor. If someone says, “The other shoe fell”, there is probably no shoe and nothing falling. You’ll need to find the original joke to understand the idiomatic meaning of the other shoe falling.\nThe meaning of a computer program is unambiguous and literal, and can be understood entirely by analysis of the tokens and structure.\nHere are some suggestions for reading programs (and other formal languages). First, remember that formal languages are much more dense than natural languages, so it takes longer to read them. Also, the structure is very important, so it is usually not a good idea to read from top to bottom, left to right. Instead, learn to parse the program in your head, identifying the tokens and interpreting the structure. Finally, the details matter. Little things like spelling errors and bad punctuation, which you can get away with in natural languages, can make a big difference in a formal language.\nThe first program Traditionally, the first program written in a new language is called Hello, World! because all it does is display the words, Hello, World! In Python, the script looks like this:\nprint(\u0026#34;Hello World!\u0026#34;) This is an example of using the print function, which doesn’t actually print anything on paper. It displays a value on the screen. In this case, the result shown is Hello, World!.\nThe quotation marks in the program mark the beginning and end of the value; they don’t appear in the result.\nSome people judge the quality of a programming language by the simplicity of the Hello, World! program. By this standard, Python does about as well as possible.\nComments As programs get bigger and more complicated, they get more difficult to read. Formal languages are dense, and it is often difficult to look at a piece of code and figure out what it is doing, or why.\nFor this reason, it is a good idea to add notes to your programs to explain in natural language what the program is doing.\nA comment in a computer program is text that is intended only for the human reader — it is completely ignored by the interpreter.\nIn Python, the # token starts a comment. The rest of the line is ignored. Here is a new version of Hello, World!.\n#--------------------------------------------------- # This demo program shows off how elegant Python is! # Written by Joe Soap, December 2010. # Anyone may freely copy or modify this program. #--------------------------------------------------- print(\u0026#34;Hello, World!\u0026#34;) # Isn\u0026#39;t this easy! You’ll also notice that we’ve left a blank line in the program. Blank lines are also ignored by the interpreter, but comments and blank lines can make your programs much easier for humans to parse. Use them!\nExercises Download the jupyter notebook!\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "How to Think Like a Computer Scientist: Learning with Python 3 (Blue Ridge Boost Edition) Version date: September 2023\nby Blue Ridge Boost LLC, pythonbook@blueridgeboost.com\n(based on previous editions by Peter Wentworth, Jeffrey Elkner, Allen B. Downey, and Chris Meyers)\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blueridgeboost.com/pythonbook/docs/",
	"title": "Docs",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blueridgeboost.com/pythonbook/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]