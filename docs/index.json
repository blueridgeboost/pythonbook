[
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_00/copyright/",
	"title": "Copyright Notice",
	"tags": [],
	"description": "",
	"content": "Copyright (C) 2023, Blue Ridge Boost LLC.\nCopyright (C) 2014, AoPS Incorporated.\nCopyright (C) Peter Wentworth, Jeffrey Elkner, Allen B. Downey and Chris Meyers.\nPermission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with Invariant Sections being Foreword, Foreword-AoPS Edition, Preface, and Contributor List, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled “GNU Free Documentation License”.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_00/foreword/",
	"title": "Foreword",
	"tags": [],
	"description": "",
	"content": "By David Beazley\nAs an educator, researcher, and book author, I am delighted to see the completion of this book. Python is a fun and extremely easy-to-use programming language that has steadily gained in popularity over the last few years. Developed over ten years ago by Guido van Rossum, Python’s simple syntax and overall feel is largely derived from ABC, a teaching language that was developed in the 1980’s. However, Python was also created to solve real problems and it borrows a wide variety of features from programming languages such as C++, Java, Modula-3, and Scheme. Because of this, one of Python’s most remarkable features is its broad appeal to professional software developers, scientists, researchers, artists, and educators.\nDespite Python’s appeal to many different communities, you may still wonder why Python? or why teach programming with Python? Answering these questions is no simple task—especially when popular opinion is on the side of more masochistic alternatives such as C++ and Java. However, I think the most direct answer is that programming in Python is simply a lot of fun and more productive.\nWhen I teach computer science courses, I want to cover important concepts in addition to making the material interesting and engaging to students. Unfortunately, there is a tendency for introductory programming courses to focus far too much attention on mathematical abstraction and for students to become frustrated with annoying problems related to low-level details of syntax, compilation, and the enforcement of seemingly arcane rules. Although such abstraction and formalism is important to professional software engineers and students who plan to continue their study of computer science, taking such an approach in an introductory course mostly succeeds in making computer science boring. When I teach a course, I don’t want to have a room of uninspired students. I would much rather see them trying to solve interesting problems by exploring different ideas, taking unconventional approaches, breaking the rules, and learning from their mistakes. In doing so, I don’t want to waste half of the semester trying to sort out obscure syntax problems, unintelligible compiler error messages, or the several hundred ways that a program might generate a general protection fault.\nOne of the reasons why I like Python is that it provides a really nice balance between the practical and the conceptual. Since Python is interpreted, beginners can pick up the language and start doing neat things almost immediately without getting lost in the problems of compilation and linking. Furthermore, Python comes with a large library of modules that can be used to do all sorts of tasks ranging from web-programming to graphics. Having such a practical focus is a great way to engage students and it allows them to complete significant projects. However, Python can also serve as an excellent foundation for introducing important computer science concepts. Since Python fully supports procedures and classes, students can be gradually introduced to topics such as procedural abstraction, data structures, and object-oriented programming — all of which are applicable to later courses on Java or C++. Python even borrows a number of features from functional programming languages and can be used to introduce concepts that would be covered in more detail in courses on Scheme and Lisp.\nIn reading Jeffrey’s preface, I am struck by his comments that Python allowed him to see a higher level of success and a lower level of frustration and that he was able to move faster with better results. Although these comments refer to his introductory course, I sometimes use Python for these exact same reasons in advanced graduate level computer science courses at the University of Chicago. In these courses, I am constantly faced with the daunting task of covering a lot of difficult course material in a blistering nine week quarter. Although it is certainly possible for me to inflict a lot of pain and suffering by using a language like C++, I have often found this approach to be counterproductive—especially when the course is about a topic unrelated to just programming. I find that using Python allows me to better focus on the actual topic at hand while allowing students to complete substantial class projects.\nAlthough Python is still a young and evolving language, I believe that it has a bright future in education. This book is an important step in that direction.\nDavid Beazley, University of Chicago, Author of the Python Essential Reference\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_00/",
	"title": "Front Matter",
	"tags": [],
	"description": "",
	"content": "Front Matter This book is an adaptation of How to Think Like a Computer Scientist: Learning with Python 3 by Peter Wentworth, Jeffrey Elkner, Allen B. Downey and Chris Meyers.\nIt was adapted and developed for Blue Ridge Boost by Nora Evans.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_00/preface/",
	"title": "Preface",
	"tags": [],
	"description": "",
	"content": "By Jeffrey Elkner\nThis book owes its existence to the collaboration made possible by the Internet and the free software movement. Its three authors—a college professor, a high school teacher, and a professional programmer—never met face to face to work on it, but we have been able to collaborate closely, aided by many other folks who have taken the time and energy to send us their feedback.\nWe think this book is a testament to the benefits and future possibilities of this kind of collaboration, the framework for which has been put in place by Richard Stallman and the Free Software Foundation.\nHow and why I came to use Python In 1999, the College Board’s Advanced Placement (AP) Computer Science exam was given in C++ for the first time. As in many high schools throughout the country, the decision to change languages had a direct impact on the computer science curriculum at Yorktown High School in Arlington, Virginia, where I teach. Up to this point, Pascal was the language of instruction in both our first-year and AP courses. In keeping with past practice of giving students two years of exposure to the same language, we made the decision to switch to C++ in the first year course for the 1997-98 school year so that we would be in step with the College Board’s change for the AP course the following year.\nTwo years later, I was convinced that C++ was a poor choice to use for introducing students to computer science. While it is certainly a very powerful programming language, it is also an extremely difficult language to learn and teach. I found myself constantly fighting with C++’s difficult syntax and multiple ways of doing things, and I was losing many students unnecessarily as a result. Convinced there had to be a better language choice for our first-year class, I went looking for an alternative to C++.\nI needed a language that would run on the machines in our GNU/Linux lab as well as on the Windows and Macintosh platforms most students have at home. I wanted it to be free software, so that students could use it at home regardless of their income. I wanted a language that was used by professional programmers, and one that had an active developer community around it. It had to support both procedural and object-oriented programming. And most importantly, it had to be easy to learn and teach. When I investigated the choices with these goals in mind, Python stood out as the best candidate for the job.\nI asked one of Yorktown’s talented students, Matt Ahrens, to give Python a try. In two months he not only learned the language but wrote an application called pyTicket that enabled our staff to report technology problems via the Web. I knew that Matt could not have finished an application of that scale in so short a time in C++, and this accomplishment, combined with Matt’s positive assessment of Python, suggested that Python was the solution I was looking for.\nFinding a textbook Having decided to use Python in both of my introductory computer science classes the following year, the most pressing problem was the lack of an available textbook.\nFree documents came to the rescue. Earlier in the year, Richard Stallman had introduced me to Allen Downey. Both of us had written to Richard expressing an interest in developing free educational materials. Allen had already written a first-year computer science textbook, How to Think Like a Computer Scientist. When I read this book, I knew immediately that I wanted to use it in my class. It was the clearest and most helpful computer science text I had seen. It emphasized the processes of thought involved in programming rather than the features of a particular language. Reading it immediately made me a better teacher.\nHow to Think Like a Computer Scientist was not just an excellent book, but it had been released under the GNU public license, which meant it could be used freely and modified to meet the needs of its user. Once I decided to use Python, it occurred to me that I could translate Allen’s original Java version of the book into the new language. While I would not have been able to write a textbook on my own, having Allen’s book to work from made it possible for me to do so, at the same time demonstrating that the cooperative development model used so well in software could also work for educational materials.\nWorking on this book for the last two years has been rewarding for both my students and me, and my students played a big part in the process. Since I could make instant changes whenever someone found a spelling error or difficult passage, I encouraged them to look for mistakes in the book by giving them a bonus point each time they made a suggestion that resulted in a change in the text. This had the double benefit of encouraging them to read the text more carefully and of getting the text thoroughly reviewed by its most important critics, students using it to learn computer science.\nFor the second half of the book on object-oriented programming, I knew that someone with more real programming experience than I had would be needed to do it right. The book sat in an unfinished state for the better part of a year until the open source community once again provided the needed means for its completion.\nI received an email from Chris Meyers expressing interest in the book. Chris is a professional programmer who started teaching a programming course last year using Python at Lane Community College in Eugene, Oregon. The prospect of teaching the course had led Chris to the book, and he started helping out with it immediately. By the end of the school year he had created a companion project on our Website at http://openbookproject.net called Python for Fun and was working with some of my most advanced students as a master teacher, guiding them beyond where I could take them.\nIntroducing programming with Python The process of translating and using How to Think Like a Computer Scientist for the past two years has confirmed Python’s suitability for teaching beginning students. Python greatly simplifies programming examples and makes important programming ideas easier to teach.\nThe first example from the text illustrates this point. It is the traditional hello, world program, which in the Java version of the book looks like this:\nclass Hello { public static void main (String[] args) { System.out.println (\u0026quot;Hello, world.\u0026quot;); } } in the Python version it becomes:\nprint(\u0026quot;Hello, World!\u0026quot;) Even though this is a trivial example, the advantages of Python stand out. Yorktown’s Computer Science I course has no prerequisites, so many of the students seeing this example are looking at their first program. Some of them are undoubtedly a little nervous, having heard that computer programming is difficult to learn. The Java version has always forced me to choose between two unsatisfying options: either to explain the class Hello, public static void main, String[] args, {, and }, statements and risk confusing or intimidating some of the students right at the start, or to tell them, Just don’t worry about all of that stuff now; we will talk about it later, and risk the same thing. The educational objectives at this point in the course are to introduce students to the idea of a programming statement and to get them to write their first program, thereby introducing them to the programming environment. The Python program has exactly what is needed to do these things, and nothing more.\nComparing the explanatory text of the program in each version of the book further illustrates what this means to the beginning student. There are seven paragraphs of explanation of Hello, world! in the Java version; in the Python version, there are only a few sentences. More importantly, the missing six paragraphs do not deal with the big ideas in computer programming but with the minutia of Java syntax. I found this same thing happening throughout the book. Whole paragraphs simply disappear from the Python version of the text because Python’s much clearer syntax renders them unnecessary.\nUsing a very high-level language like Python allows a teacher to postpone talking about low-level details of the machine until students have the background that they need to better make sense of the details. It thus creates the ability to put first things first pedagogically. One of the best examples of this is the way in which Python handles variables. In Java a variable is a name for a place that holds a value if it is a built-in type, and a reference to an object if it is not. Explaining this distinction requires a discussion of how the computer stores data. Thus, the idea of a variable is bound up with the hardware of the machine. The powerful and fundamental concept of a variable is already difficult enough for beginning students (in both computer science and algebra). Bytes and addresses do not help the matter. In Python a variable is a name that refers to a thing. This is a far more intuitive concept for beginning students and is much closer to the meaning of variable that they learned in their math courses. I had much less difficulty teaching variables this year than I did in the past, and I spent less time helping students with problems using them.\nAnother example of how Python aids in the teaching and learning of programming is in its syntax for functions. My students have always had a great deal of difficulty understanding functions. The main problem centers around the difference between a function definition and a function call, and the related distinction between a parameter and an argument. Python comes to the rescue with syntax that is nothing short of beautiful. Function definitions begin with the keyword def, so I simply tell my students, When you define a function, begin with def, followed by the name of the function that you are defining; when you call a function, simply call (type) out its name. Parameters go with definitions; arguments go with calls. There are no return types, parameter types, or reference and value parameters to get in the way, so I am now able to teach functions in less than half the time that it previously took me, with better comprehension.\nUsing Python improved the effectiveness of our computer science program for all students. I saw a higher general level of success and a lower level of frustration than I experienced teaching with either C++ or Java. I moved faster with better results. More students left the course with the ability to create meaningful programs and with the positive attitude toward the experience of programming that this engenders.\nBuilding a community I have received email from all over the globe from people using this book to learn or to teach programming. A user community has begun to emerge, and many people have been contributing to the project by sending in materials for the companion Website at http://openbookproject.net/pybiblio.\nWith the continued growth of Python, I expect the growth in the user community to continue and accelerate. The emergence of this user community and the possibility it suggests for similar collaboration among educators have been the most exciting parts of working on this project for me. By working together, we can increase the quality of materials available for our use and save valuable time. I invite you to join our community and look forward to hearing from you. Please write to me at\njeff@elkner.net\nJeffrey Elkner\nGovernor’s Career and Technical Academy in Arlington\nArlington, Virginia\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_00/contrib/",
	"title": "Contributor List",
	"tags": [],
	"description": "",
	"content": "To paraphrase the philosophy of the Free Software Foundation, this book is free like free speech, but not necessarily free like free pizza. It came about because of a collaboration that would not have been possible without the GNU Free Documentation License. So we would like to thank the Free Software Foundation for developing this license and, of course, making it available to us.\nWe would also like to thank the more than 100 sharp-eyed and thoughtful readers who have sent us suggestions and corrections over the past few years. In the spirit of free software, we decided to express our gratitude in the form of a contributor list. Unfortunately, this list is not complete, but we are doing our best to keep it up to date. It was also getting too large to include everyone who sends in a typo or two. You have our gratitude, and you have the personal satisfaction of making a book you found useful better for you and everyone else who uses it. New additions to the list for the 2nd edition will be those who have made on-going contributions.\nIf you have a chance to look through the list, you should realize that each person here has spared you and all subsequent readers from the confusion of a technical error or a less-than-transparent explanation, just by sending us a note.\nImpossible as it may seem after so many corrections, there may still be errors in this book. If you should stumble across one, we hope you will take a minute to contact us. The email address (for the Python 3 version of the book) is p.wentworth@ru.ac.za . Substantial changes made due to your suggestions will add you to the next version of the contributor list (unless you ask to be omitted). Thank you!\nSecond Edition   An email from Mike MacHenry set me straight on tail recursion. He not only pointed out an error in the presentation, but suggested how to correct it.\n  It wasn’t until 5th Grade student Owen Davies came to me in a Saturday morning Python enrichment class and said he wanted to write the card game, Gin Rummy, in Python that I finally knew what I wanted to use as the case study for the object oriented programming chapters.\n  A special thanks to pioneering students in Jeff’s Python Programming class at GCTAA during the 2009-2010 school year: Safath Ahmed, Howard Batiste, Louis Elkner-Alfaro, and Rachel Hancock. Your continual and thoughtfull feedback led to changes in most of the chapters of the book. You set the standard for the active and engaged learners that will help make the new Governor’s Academy what it is to become. Thanks to you this is truly a student tested text.\n  Thanks in a similar vein to the students in Jeff’s Computer Science class at the HB-Woodlawn program during the 2007-2008 school year: James Crowley, Joshua Eddy, Eric Larson, Brian McGrail, and Iliana Vazuka.\n  Ammar Nabulsi sent in numerous corrections from Chapters 1 and 2.\n  Aldric Giacomoni pointed out an error in our definition of the Fibonacci sequence in Chapter 5.\n  Roger Sperberg sent in several spelling corrections and pointed out a twisted piece of logic in Chapter 3.\n  Adele Goldberg sat down with Jeff at PyCon 2007 and gave him a list of suggestions and corrections from throughout the book.\n  Ben Bruno sent in corrections for chapters 4, 5, 6, and 7.\n  Carl LaCombe pointed out that we incorrectly used the term commutative in chapter 6 where symmetric was the correct term.\n  Alessandro Montanile sent in corrections for errors in the code examples and text in chapters 3, 12, 15, 17, 18, 19, and 20.\n  Emanuele Rusconi found errors in chapters 4, 8, and 15.\n  Michael Vogt reported an indentation error in an example in chapter 6, and sent in a suggestion for improving the clarity of the shell vs. script section in chapter 1.\n  First Edition  Lloyd Hugh Allen sent in a correction to Section 8.4. Yvon Boulianne sent in a correction of a semantic error in Chapter 5. Fred Bremmer submitted a correction in Section 2.1. Jonah Cohen wrote the Perl scripts to convert the LaTeX source for this book into beautiful HTML. Michael Conlon sent in a grammar correction in Chapter 2 and an improvement in style in Chapter 1, and he initiated discussion on the technical aspects of interpreters. Benoit Girard sent in a correction to a humorous mistake in Section 5.6. Courtney Gleason and Katherine Smith wrote horsebet.py, which was used as a case study in an earlier version of the book. Their program can now be found on the website. Lee Harr submitted more corrections than we have room to list here, and indeed he should be listed as one of the principal editors of the text. James Kaylin is a student using the text. He has submitted numerous corrections. David Kershaw fixed the broken catTwice function in Section 3.10. Eddie Lam has sent in numerous corrections to Chapters 1, 2, and 3. He also fixed the Makefile so that it creates an index the first time it is run and helped us set up a versioning scheme. Man-Yong Lee sent in a correction to the example code in Section 2.4. David Mayo pointed out that the word unconsciously in Chapter 1 needed to be changed to subconsciously . Chris McAloon sent in several corrections to Sections 3.9 and 3.10. Matthew J. Moelter has been a long-time contributor who sent in numerous corrections and suggestions to the book. Simon Dicon Montford reported a missing function definition and several typos in Chapter 3. He also found errors in the increment function in Chapter 13. John Ouzts corrected the definition of return value in Chapter 3. Kevin Parks sent in valuable comments and suggestions as to how to improve the distribution of the book. David Pool sent in a typo in the glossary of Chapter 1, as well as kind words of encouragement. Michael Schmitt sent in a correction to the chapter on files and exceptions. Robin Shaw pointed out an error in Section 13.1, where the printTime function was used in an example without being defined. Paul Sleigh found an error in Chapter 7 and a bug in Jonah Cohen’s Perl script that generates HTML from LaTeX. Craig T. Snydal is testing the text in a course at Drew University. He has contributed several valuable suggestions and corrections. Ian Thomas and his students are using the text in a programming course. They are the first ones to test the chapters in the latter half of the book, and they have make numerous corrections and suggestions. Keith Verheyden sent in a correction in Chapter 3. Peter Winstanley let us know about a longstanding error in our Latin in Chapter 3. Chris Wrobel made corrections to the code in the chapter on file I/O and exceptions. Moshe Zadka has made invaluable contributions to this project. In addition to writing the first draft of the chapter on Dictionaries, he provided continual guidance in the early stages of the book. Christoph Zwerschke sent several corrections and pedagogic suggestions, and explained the difference between gleich and selbe. James Mayer sent us a whole slew of spelling and typographical errors, including two in the contributor list. Hayden McAfee caught a potentially confusing inconsistency between two examples. Angel Arnal is part of an international team of translators working on the Spanish version of the text. He has also found several errors in the English version. Tauhidul Hoque and Lex Berezhny created the illustrations in Chapter 1 and improved many of the other illustrations. Dr. Michele Alzetta caught an error in Chapter 8 and sent some interesting pedagogic comments and suggestions about Fibonacci and Old Maid. Andy Mitchell caught a typo in Chapter 1 and a broken example in Chapter 2. Kalin Harvey suggested a clarification in Chapter 7 and caught some typos. Christopher P. Smith caught several typos and is helping us prepare to update the book for Python 2.2. David Hutchins caught a typo in the Foreword. Gregor Lingl is teaching Python at a high school in Vienna, Austria. He is working on a German translation of the book, and he caught a couple of bad errors in Chapter 5. Julie Peters caught a typo in the Preface.  "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/",
	"title": "The Way of the Program",
	"tags": [],
	"description": "",
	"content": "Chapter 1 The Way of the Program The goal of this book is to teach you to think like a computer scientist.\nAs computer scientists, we will combine some of the best features of mathematics, engineering, and natural science. Like mathematicians, we will use formal languages to communicate our ideas. Like engineers, we will design complex systems, assembling components into systems and evaluating tradeoffs among alternatives. Like scientists, we will observe the behavior of complex systems, form hypotheses, and test predictions.\nThe single most important skill for a computer scientist is problem solving. Problem solving is a skill that involves formulating problems, thinking creatively about solutions, and expressing a solution clearly and accurately. As it turns out, the process of learning to program is an excellent opportunity to practice problem-solving skills. That’s why this chapter is called The way of the program.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s01/",
	"title": "The Python Programming Language",
	"tags": [],
	"description": "",
	"content": "The programming language you will be learning is Python. Python is an example of a high-level language; other high-level languages you might have heard of are C++, PHP, Pascal, C#, and Java.\nAs you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Loosely speaking, computers can only execute programs written in low-level languages. Thus, programs written in a high-level language have to be translated into something more suitable before they can run.\nAlmost all programs are written in high-level languages because of their advantages. It is much easier to program in a high-level language so programs take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications.\nThe engine that translates and runs Python is called the Python Interpreter: There are two ways to use it: immediate mode and script mode. In immediate mode, which we also call shell mode, you type Python expressions into the Python interpreter window (which is also called the shell), and the interpreter immediately shows the result.\nIn AoPS classes, we will use the IDLE application that comes built-in with most Python installations. In IDLE, the Python interpreter window is labeled Python Shell.\nInstructions for installing Python on your computer are including in the Course Introduction document on the AoPS class homepage, and are also posted on the class message board. When you start up IDLE on your computer, it should look something like this:\nThe \u0026gt;\u0026gt; is called the Python prompt. The interpreter uses the prompt to indicate that it is ready for instructions. We typed 2+2, and the interpreter evaluated our expression, and replied 4, and on the next line it gave a new prompt, indicating that it is ready for more.\nAlternatively, you can write a program in a file and use the interpreter to run the lines of code in the file. Such a file is called a script. Scripts have the advantage that they can be saved, printed, and so on. A Python script is often called a module.\nFor example, we can created a file named firstprogram.py using IDLE. By convention, files that contain Python programs have names that end with .py. To do this, select “New File” or “New Window” from the File menu of IDLE, and then type the following two lines into the new window that appears:\nTo run the program, we can select the “Run Module” or “Run Program” option from the “Run” menu of IDLE (or alternatively you can press the F5 key). IDLE will ask you to save your program before it can run it. Save it using the name firstprogram.py. Then your program will run, and it should look something like the screenshot below:\nNotice that the program always runs in the Shell window.\nDon’t worry, most programs are more interesting than this one.\nWorking directly in the interpreter is convenient for testing short bits of code because you get immediate feedback. Think of it as scratch paper used to help you work out problems. Anything longer than a few lines should be put into a script.\nThere’s a third way that you can run Python using this ebook. In many places in this ebook, we’ll have a Python interpreter built directly into the text. For example, our program from above can appear directly in the book as shown below:\nprint('My first program adds two numbers.') print(2+3) If you click the “Run” button, the program will run and you’ll see its output above directly in the ebook. You can also edit the code directly in the window above. If you click the “Reset” button (or refresh your browser window), the code will return to what it originally was (that is, any edits that you’ve made will be removed.) The little numbers to the left are line numbers, and you don’t type them in. They appear automatically in our ebook, so that it’s easier for us to discuss our program. For example, we can say “line 1 of our program prints a sentence”.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s02/",
	"title": "What is a program?",
	"tags": [],
	"description": "",
	"content": "A program is a sequence of instructions that specifies how to perform a computation. The computation might be something mathematical, such as solving a system of equations or finding the roots of a polynomial, but it can also be a symbolic computation, such as searching and replacing text in a document.\nThe details look different in different languages, but a few basic instructions appear in just about every language:\n input. Get data from the keyboard, a file, or some other device. output. Display data on the screen or send data to a file or other device. math. Perform basic mathematical operations like addition and multiplication. conditional execution. Check for certain conditions and execute the appropriate sequence of statements. repetition. Perform some action repeatedly, usually with some variation.  Believe it or not, that’s pretty much all there is to it. Every program you’ve ever used, no matter how complicated, is made up of instructions that look more or less like these. Thus, we can describe programming as the process of breaking a large, complex task into smaller and smaller subtasks until the subtasks are simple enough to be performed with sequences of these basic instructions.\nThat may be a little vague, but we will come back to this topic later when we talk about algorithms.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s03/",
	"title": "What is debugging?",
	"tags": [],
	"description": "",
	"content": "Programming is a complex process, and because it is done by human beings, it often leads to errors. Programming errors are called bugs and the process of tracking them down and correcting them is called debugging. Use of the term bug to describe small engineering difficulties dates back to at least 1889, when Thomas Edison had a bug with his phonograph.\nThree kinds of errors can occur in a program: syntax errors, runtime errors, and semantic errors. It is useful to distinguish between them in order to track them down more quickly.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s04/",
	"title": "Syntax errors",
	"tags": [],
	"description": "",
	"content": "Python can only execute a program if the program is syntactically correct; otherwise, the process fails and returns an error message. Syntax refers to the structure of a program and the rules about that structure. For example, in English, a sentence must begin with a capital letter and end with a period. this sentence contains a syntax error. So does this one\nFor most humans, a few syntax errors are not a significant problem, which is why we can read the above sentences and still figure out what they mean. Python is not so forgiving. If there is a single syntax error anywhere in your program, Python will display an error message and quit, and you will not be able to run your program. During the first few weeks of your programming career, you will probably spend a lot of time tracking down syntax errors. As you gain experience, though, you will make fewer errors and find them faster.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s05/",
	"title": "Runtime errors",
	"tags": [],
	"description": "",
	"content": "The second type of error is a runtime error, so called because the error does not appear until you run the program. These errors are also called exceptions because they usually indicate that something exceptional (and bad) has happened.\nRuntime errors are rare in the simple programs you will see in the first few chapters, so it might be a while before you encounter one.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s06/",
	"title": "Semantic errors",
	"tags": [],
	"description": "",
	"content": "The third type of error is the semantic error. If there is a semantic error in your program, it will run successfully, in the sense that the computer will not generate any error messages, but it will not do the right thing. It will do something else. Specifically, it will do what you told it to do.\nThe problem is that the program you wrote is not the program you wanted to write. The meaning of the program (its semantics) is wrong. Identifying semantic errors can be tricky because it requires you to work backward by looking at the output of the program and trying to figure out what it is doing.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s07/",
	"title": "Experimental debugging",
	"tags": [],
	"description": "",
	"content": "One of the most important skills you will acquire is debugging. Although it can be frustrating, debugging is one of the most intellectually rich, challenging, and interesting parts of programming.\nIn some ways, debugging is like detective work. You are confronted with clues, and you have to infer the processes and events that led to the results you see.\nDebugging is also like an experimental science. Once you have an idea what is going wrong, you modify your program and try again. If your hypothesis was correct, then you can predict the result of the modification, and you take a step closer to a working program. If your hypothesis was wrong, you have to come up with a new one. As Sherlock Holmes pointed out: When you have eliminated the impossible, whatever remains, however improbable, must be the truth. (A. Conan Doyle, The Sign of Four)\nFor some people, programming and debugging are the same thing. That is, programming is the process of gradually debugging a program until it does what you want. The idea is that you should start with a program that does something and make small modifications, debugging them as you go, so that you always have a working program.\nLater chapters will make more suggestions about debugging and other programming practices.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s08/",
	"title": "Formal and natural languages",
	"tags": [],
	"description": "",
	"content": "Natural languages are the languages that people speak, such as English, Spanish, and French. They were not designed by people (although people try to impose some order on them); they evolved naturally.\nFormal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. And most importantly:\nProgramming languages are formal languages that have been designed to express computations. Formal languages tend to have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6 is not. H~2~O is a syntactically correct chemical name, but ~2~Zz is not.\nSyntax rules come in two flavors, pertaining to tokens and structure. Tokens are the basic elements of the language, such as words, numbers, parentheses, commas, and so on. In Python, a statement like\nprint(\u0026quot;Happy New Year\u0026quot;)\nhas 6 tokens: a function name, an open parenthesis (round bracket), a string, a comma, a number, and a close parenthesis.\nIt is possible to make errors in the way one constructs tokens. One of the problems with 3=+6 is that ```$`````` is not a legal token in mathematics (at least as far as we know). Similarly, ~2 Zz is not a legal token in chemistry notation because there is no element with the abbreviation Zz.\nThe second type of syntax rule pertains to the structure of a statement— that is, the way the tokens are arranged. The statement ```3=+6`````` is structurally illegal because you can’t place a plus sign immediately after an equal sign. Similarly, molecular formulas have to have subscripts after the element name, not before. And in our Python example, if we omitted the comma, or if we changed the two parentheses around to say\nprint)\u0026quot;Happy New Year!\u0026quot;( our statement would still have six legal and valid tokens, but the structure is illegal.\nWhen you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is (although in a natural language you do this subconsciously). This process is called parsing.\nFor example, when you hear the sentence, “The other shoe fell”, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence.\nAlthough formal and natural languages have many features in common — tokens, structure, syntax, and semantics — there are many differences:\n ambiguity  Natural languages are full of ambiguity, which people deal with by using contextual clues and other information. Formal languages are designed to be nearly or completely unambiguous, which means that any statement has exactly one meaning, regardless of context.\nredundancy  In order to make up for ambiguity and reduce misunderstandings, natural languages employ lots of redundancy. As a result, they are often verbose. Formal languages are less redundant and more concise.\nliteralness  Formal languages mean exactly what they say. On the other hand, natural languages are full of idiom and metaphor. If someone says, “The other shoe fell”, there is probably no shoe and nothing falling. You’ll need to find the original joke to understand the idiomatic meaning of the other shoe falling.\nThe meaning of a computer program is unambiguous and literal, and can be understood entirely by analysis of the tokens and structure.\nHere are some suggestions for reading programs (and other formal languages). First, remember that formal languages are much more dense than natural languages, so it takes longer to read them. Also, the structure is very important, so it is usually not a good idea to read from top to bottom, left to right. Instead, learn to parse the program in your head, identifying the tokens and interpreting the structure. Finally, the details matter. Little things like spelling errors and bad punctuation, which you can get away with in natural languages, can make a big difference in a formal language.\nThe first program Traditionally, the first program written in a new language is called Hello, World! because all it does is display the words, Hello, World! In Python, the script looks like this:\nprint(\u0026quot;Hello World!\u0026quot;) This is an example of using the print function, which doesn’t actually print anything on paper. It displays a value on the screen. In this case, the result shown is Hello, World!.\nThe quotation marks in the program mark the beginning and end of the value; they don’t appear in the result.\nSome people judge the quality of a programming language by the simplicity of the Hello, World! program. By this standard, Python does about as well as possible.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s09/",
	"title": "Comments",
	"tags": [],
	"description": "",
	"content": "As programs get bigger and more complicated, they get more difficult to read. Formal languages are dense, and it is often difficult to look at a piece of code and figure out what it is doing, or why.\nFor this reason, it is a good idea to add notes to your programs to explain in natural language what the program is doing.\nA comment in a computer program is text that is intended only for the human reader — it is completely ignored by the interpreter.\nIn Python, the # token starts a comment. The rest of the line is ignored. Here is a new version of Hello, World!.\n#--------------------------------------------------- # This demo program shows off how elegant Python is! # Written by Joe Soap, December 2010. # Anyone may freely copy or modify this program. #--------------------------------------------------- print(\u0026quot;Hello, World!\u0026quot;) # Isn't this easy! You’ll also notice that we’ve left a blank line in the program. Blank lines are also ignored by the interpreter, but comments and blank lines can make your programs much easier for humans to parse. Use them!\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_01/s10/",
	"title": "Exercises",
	"tags": [],
	"description": "",
	"content": "Work in the jupyter notebook!\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/",
	"title": "Variables, expressions and statements",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Variables, expressions and statements "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s01/",
	"title": "Values and data types",
	"tags": [],
	"description": "",
	"content": "A value is one of the fundamental things — like a letter or a number — that a program manipulates. Some of the values we have seen so far are 5 (the result when we added 2+3), and Hello World!.\nThese values are classified into different classes, or data types: 5 is an integer, and \u0026quot;Hello, World!\u0026quot; is a string, so-called because it contains a string of letters. You (and the interpreter) can identify strings because they are enclosed in quotation marks.\nIf you are not sure what class a value falls into, Python has a function called type which can tell you, as in the example below. (Anytime we show you an example with lines that start with \u0026gt;\u0026gt;\u0026gt;, these are examples that you can try in the IDLE shell.)\n\u0026gt;\u0026gt;\u0026gt; type(\u0026quot;Hello, World!\u0026quot;) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(17) \u0026lt;class 'int'\u0026gt; Not surprisingly, strings belong to the class str and integers belong to the class int. Less obviously, numbers with a decimal point belong to a class called float, because these numbers are represented in a format called floating-point. At this stage, you can treat the words class and type interchangeably.\n\u0026gt;\u0026gt;\u0026gt; type(3.2) \u0026lt;class 'float'\u0026gt; What about values like \u0026quot;17\u0026quot; and \u0026quot;3.2\u0026quot;? They look like numbers, but they are in quotation marks like strings.\n\u0026gt;\u0026gt;\u0026gt; type(\u0026quot;17\u0026quot;) \u0026lt;class \u0026quot;str\u0026quot;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(\u0026quot;;3.2\u0026quot;;) \u0026lt;class \u0026quot;str\u0026quot;\u0026gt; They’re strings!\nStrings in Python can be enclosed in either single quotes (') or double quotes (\u0026quot;), or three of each (''' or \u0026quot;\u0026quot;\u0026quot;)\n\u0026gt;\u0026gt;\u0026gt; type('This is a string.') \u0026lt;class \u0026quot;str\u0026quot;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(\u0026quot;And so is this.\u0026quot;) \u0026lt;class \u0026quot;str\u0026quot;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type('''and this.''') \u0026lt;class \u0026quot;str\u0026quot;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(\u0026quot;\u0026quot;\u0026quot;and even this...\u0026quot;\u0026quot;\u0026quot;) \u0026lt;class \u0026quot;str\u0026quot;\u0026gt; Double quoted strings can contain single quotes inside them, as in \u0026quot;Bruce's beard\u0026quot;, and single quoted strings can have double quotes inside them, as in 'The knights who say \u0026quot;Ni!\u0026quot;'. Strings enclosed with three occurrences of either quote symbol are called triple quoted strings. They can contain either single or double quotes:\n\u0026gt;\u0026gt;\u0026gt; print(\u0026quot;\u0026quot;\u0026quot;\u0026quot;Oh no\u0026quot;, she exclaimed, \u0026quot;Ben's bike is broken!\u0026quot;\u0026quot;\u0026quot;\u0026quot;) \u0026quot;Oh no\u0026quot;, she exclaimed, \u0026quot;Ben's bike is broken!\u0026quot; Triple quoted strings can even span multiple lines:\n\u0026gt;\u0026gt;\u0026gt; message = \u0026quot;\u0026quot;\u0026quot;This message will ... span several ... lines.\u0026quot;\u0026quot;\u0026quot; \u0026gt;\u0026gt;\u0026gt; print(message) This message will span several lines. Python doesn’t care whether you use single or double quotes or the three-of-a-kind quotes to surround your strings: once it has parsed the text of your program or command, the way it stores the value is identical in all cases, and the surrounding quotes are not part of the value. But when the interpreter wants to display a string, it has to decide which quotes to use to make it look like a string.\n\u0026gt;\u0026gt;\u0026gt; \u0026quot;This is a string.\u0026quot; \u0026quot;This is a string.\u0026quot; \u0026gt;\u0026gt;\u0026gt; \u0026quot;\u0026quot;\u0026quot;And so is this.\u0026quot;\u0026quot;\u0026quot; \u0026quot;And so is this.\u0026quot; So the Python language designers usually chose to surround their strings by single quotes. What do think would happen if the string already contained single quotes?\nWhen you type a large integer, you might be tempted to use commas between groups of three digits, as in 42,000. This is not a legal integer in Python, but it does mean something else, which is legal:\n\u0026gt;\u0026gt;\u0026gt; 42000 42000 \u0026gt;\u0026gt;\u0026gt; 42,000 (42, 0) Well, that’s not what we expected at all! Because of the comma, Python chose to treat this as a pair of values. We’ll come back to learn about pairs later. But, for the moment, remember not to put commas or spaces in your integers, no matter how big they are. Also revisit what we said in the previous chapter: formal languages are strict, the notation is concise, and even the smallest change might mean something quite different from what you intended.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s02/",
	"title": "Variables",
	"tags": [],
	"description": "",
	"content": "One of the most powerful features of a programming language is the ability to manipulate variables. A variable is a name that refers to a value.\nThe assignment statement gives a value to a variable:\n\u0026gt;\u0026gt;\u0026gt; message = \u0026quot;What's up, Doc?\u0026quot; \u0026gt;\u0026gt;\u0026gt; n = 17 \u0026gt;\u0026gt;\u0026gt; pi = 3.14159 This example makes three assignments. The first assigns the string value \u0026quot;What's up, Doc?\u0026quot; to a variable named message. The second gives the integer 17 to n, and the third assigns the floating-point number 3.14159 to a variable called pi.\nThe assignment token, =, should not be confused with equals, which uses the token ==. The assignment statement assigns a name, on the left-hand side of the operator, to a value, on the right-hand side. This is why you will get an error if you enter:\n\u0026gt;\u0026gt;\u0026gt; 17 = n SyntaxError: can't assign to literal Tip. When reading or writing code, say to yourself “n is assigned 17” or “n gets the value 17”. Don’t say “n equals 17”.\nA common way to represent variables on paper is to write the name with an arrow pointing to the variable’s value. This kind of figure is called a state snapshot because it shows what state each of the variables is in at a particular instant in time. (Think of it as the variable’s state of mind). This diagram shows the result of executing the assignment statements:\nIf you ask the interpreter to evaluate a variable, it will produce the value that is currently linked to the variable:\n\u0026gt;\u0026gt;\u0026gt; message 'What's up, Doc?' \u0026gt;\u0026gt;\u0026gt; n 17 \u0026gt;\u0026gt;\u0026gt; pi 3.14159 We use variables in a program to “remember” things, perhaps the current score at the football game. But variables are variable. This means they can change over time, just like the scoreboard at a football game. You can assign a value to a variable, and later assign a different value to the same variable. (This is different from math. In math, if you give x the value 3, it cannot change to link to a different value half-way through your calculations!)\n\u0026gt;\u0026gt;\u0026gt; day = \u0026quot;Thursday\u0026quot; \u0026gt;\u0026gt;\u0026gt; day 'Thursday' \u0026gt;\u0026gt;\u0026gt; day = \u0026quot;Friday\u0026quot; \u0026gt;\u0026gt;\u0026gt; day 'Friday' \u0026gt;\u0026gt;\u0026gt; day = 21 \u0026gt;\u0026gt;\u0026gt; day 21 You’ll notice we changed the value of day three times, and on the third assignment we even made it refer to a value that was of a different type.\nA great deal of programming is about having the computer remember things, for example the number of missed calls on your phone, and then arranging to update or change the variable when you miss another call.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s03/",
	"title": "Variable names and keywords",
	"tags": [],
	"description": "",
	"content": "Variable names can be arbitrarily long. They can contain both letters and digits, but they have to begin with a letter or an underscore. Although it is legal to use uppercase letters, by convention we don’t. If you do, remember that case matters. Bruce and bruce are different variables.\nThe underscore character (_) can appear in a name. It is often used in names with multiple words, such as my_name or price_of_tea_in_china. For variable names, a common convention is to use something called mixedCase, where multiple words are combined together and every word except the first is capitalized. So, for example, using mixedCase we would have the variables myName or priceOfTeaInChina.\nThere are some situations in which names beginning with an underscore have special meaning, so a safe rule for beginners is to start all names with a letter.\nIf you give a variable an illegal name, you get a syntax error:\n\u0026gt;\u0026gt;\u0026gt; 76trombones = \u0026quot;big parade\u0026quot; SyntaxError: invalid syntax \u0026gt;\u0026gt;\u0026gt; more$ = 1000000 SyntaxError: invalid syntax \u0026gt;\u0026gt;\u0026gt; class = \u0026quot;Computer Science 101\u0026quot; SyntaxError: invalid syntax 76trombones is illegal because it does not begin with a letter. more$ is illegal because it contains an illegal character, the dollar sign. But what’s wrong with class?\nIt turns out that class is one of the Python keywords. Keywords define the language’s syntax rules and structure, and they cannot be used as variable names.\nAs of this writing, Python has 33 keywords (and every now and again improvements to Python introduce or eliminate one or two):\n  False def if raise  None del import return  True elif in try  and else is while  as except lambda with  assert finally nonlocal yield  break for not \u0026nbsp;  class from or \u0026nbsp;  continue global pass \u0026nbsp;    You might want to keep this list handy. You\u0026#8217;ll learn what most of these keywords mean as you progress through this book. You can also type ```help('keywords')``` in the shell to see a list of the Python keywords. Also, when you type a keyword in IDLE, it should appear in orange. If the interpreter complains about one of your variable names and you don\u0026#8217;t know why, see if it is on this list. Programmers generally choose names for their variables that are meaningful to the human readers of the program — they help the programmer document, or remember, what the variable is used for.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s04/",
	"title": "Statements",
	"tags": [],
	"description": "",
	"content": "A statement is an instruction that the Python interpreter can execute. We have only seen the assignment statement so far. Some other kinds of statements that we’ll see shortly are while statements, for statements, if statements, and import statements. (There are other kinds too!)\nWhen you type a statement on the command line, Python executes it. Statements don’t produce any result.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s05/",
	"title": "Evaluating expressions",
	"tags": [],
	"description": "",
	"content": "An expression is a combination of values, variables, operators, and calls to functions. If you type an expression at the Python prompt, the interpreter evaluates it and displays the result:\n\u0026gt;\u0026gt;\u0026gt; 1 + 1 2 \u0026gt;\u0026gt;\u0026gt; len(\u0026quot;hello\u0026quot;) 5 In this example len is a built-in Python function that returns the number of characters in a string. We’ve previously seen the print and the type functions, so this is our third example of a function!\nThe evaluation of an expression produces a value, which is why expressions can appear on the right hand side of assignment statements. A value all by itself is a simple expression, and so is a variable.\n\u0026gt;\u0026gt;\u0026gt; 17 17 \u0026gt;\u0026gt;\u0026gt; y = 3.14 \u0026gt;\u0026gt;\u0026gt; x = len(\u0026quot;hello\u0026quot;) \u0026gt;\u0026gt;\u0026gt; x 5 \u0026gt;\u0026gt;\u0026gt; y 3.14 "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s06/",
	"title": "Operators and operands",
	"tags": [],
	"description": "",
	"content": "Operators are special tokens that represent computations like addition, multiplication and division. The values the operator uses are called operands.\nThe following are all legal Python expressions whose meaning is more or less clear:\n20+32 hour-1 hour*60+minute minute/60 5**2 (5+9)*(15-7) The tokens +, -, and *, and the use of parenthesis for grouping, mean in Python what they mean in mathematics. The asterisk (*) is the token for multiplication, and ** is the token for exponentiation.\n\u0026gt;\u0026gt;\u0026gt; 2 ** 3 8 \u0026gt;\u0026gt;\u0026gt; 3 ** 2 9 When a variable name appears in the place of an operand, it is replaced with its value before the operation is performed.\nAddition, subtraction, multiplication, and exponentiation all do what you expect.\nExample: so let us convert 645 minutes into hours:\n\u0026gt;\u0026gt;\u0026gt; minutes = 645 \u0026gt;\u0026gt;\u0026gt; hours = minutes / 60 \u0026gt;\u0026gt;\u0026gt; hours 10.75 Oops! In Python 3, the division operator / always yields a floating point result. What we might have wanted to know was how many whole hours there are, and how many minutes remain. Python gives us two different flavors of the division operator. The second, called floor division uses the token //. Its result is always a whole number — and if it has to adjust the number it always moves it to the left on the number line. So 6 // 4 yields 1, but -6 // 4 might surprise you!\n\u0026gt;\u0026gt;\u0026gt; 7 / 4 1.75 \u0026gt;\u0026gt;\u0026gt; 7 // 4 1 \u0026gt;\u0026gt;\u0026gt; minutes = 645 \u0026gt;\u0026gt;\u0026gt; hours = minutes // 60 \u0026gt;\u0026gt;\u0026gt; hours 10 Take care that you choose the correct flavor of the division operator. If you’re working with expressions where you need floating point values, use the division operator that does the division accurately.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s07/",
	"title": "Type converter functions",
	"tags": [],
	"description": "",
	"content": "Here we’ll look at three more Python functions, int, float and str, which will (attempt to) convert their arguments into types int, float and str respectively. We call these type converter functions.\nThe int function can take a floating point number or a string, and turn it into an int. For floating point numbers, it discards the decimal portion of the number — a process we call truncation towards zero on the number line. Let us see this in action:\n\u0026gt;\u0026gt;\u0026gt; int(3.14) 3 \u0026gt;\u0026gt;\u0026gt; int(3.9999) # This doesn't round to the closest int! 3 \u0026gt;\u0026gt;\u0026gt; int(3.0) 3 \u0026gt;\u0026gt;\u0026gt; int(-3.999) # Note that the result is closer to zero -3 \u0026gt;\u0026gt;\u0026gt; int(minutes / 60) 10 \u0026gt;\u0026gt;\u0026gt; int(\u0026quot;2345\u0026quot;) # Parse a string to produce an int 2345 \u0026gt;\u0026gt;\u0026gt; int(17) # It even works if arg is already an int 17 \u0026gt;\u0026gt;\u0026gt; int(\u0026quot;23 bottles\u0026quot;) This last case doesn’t look like a number — what do we expect?\nTraceback (most recent call last): File \u0026quot;\u0026amp;lt;pyshell#4\u0026gt;\u0026quot;, line 1, in \u0026amp;lt;module\u0026gt; int(\u0026quot;23 bottles\u0026quot;) ValueError: invalid literal for int() with base 10: '23 bottles' The type converter float can turn an integer, a float, or a syntactically legal string into a float:\n\u0026gt;\u0026gt;\u0026gt; float(17) 17.0 \u0026gt;\u0026gt;\u0026gt; float(\u0026quot;123.45\u0026quot;) 123.45 The type converter str turns its argument into a string:\n\u0026gt;\u0026gt;\u0026gt; str(17) '17' \u0026gt;\u0026gt;\u0026gt; str(123.45) '123.45' "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s08/",
	"title": "Order of operations",
	"tags": [],
	"description": "",
	"content": "When more than one operator appears in an expression, the order of evaluation depends on the rules of precedence. Python follows the same precedence rules for its mathematical operators that mathematics does. The acronym PEMDAS (which some people remember as “Please Excuse My Dear Aunt Sally”) is a useful way to remember the order of operations:\n**P**arentheses have the highest precedence and can be used to force an expression to evaluate in the order you want. Since expressions in parentheses are evaluated first, ```2 * (3-1)```\\ is 4, and ```(1+1)**(5-2)```\\ is 8. You can also use parentheses to make an expression easier to read, as in ```(minute * 100) / 60```\\, even though it doesn\u0026#8217;t change the result.  **E**xponentiation has the next highest precedence, so ```2**1+1```\\ is 3 and not 4, and ```3*1**3```\\ is 3 and not 27.  **M**ultiplication and both **D**ivision operators have the same precedence, which is higher than **A**ddition and **S**ubtraction, which also have the same precedence. So ```2*3-1```\\ yields 5 rather than 4, and ```5-2*2```\\ is 1, not 6.  Operators with the *same* precedence are evaluated from left-to-right. In algebra we say they are *left-associative*. So in the expression ```6-3+2```\\, the subtraction happens first, yielding 3. We then add 2 to get the result 5. If the operations had been evaluated from right to left, the result would have been ```6-(3+2)```\\, which is 1. (The acronym PEDMAS could mislead you to thinking that division has higher precedence than multiplication, and addition is done ahead of subtraction - don\u0026#8217;t be misled. Subtraction and addition are at the same precedence, and the left-to-right rule applies.)  An exception to the left-to-right left-associative rule is the exponentiation operator ```**```\\, so a useful hint is to always use parentheses to force exactly the order you want when exponentiation is involved: \u0026gt;\u0026gt;\u0026gt; 2 ** 3 ** 2 # The right-most ** operator gets done first! 512 \u0026gt;\u0026gt;\u0026gt; (2 ** 3) ** 2 # Use parentheses to force the order you want! 64 The immediate mode command prompt of Python is great for exploring and experimenting with expressions like this.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s09/",
	"title": "Operations on strings",
	"tags": [],
	"description": "",
	"content": "In general, you cannot perform mathematical operations on strings, even if the strings look like numbers. The following are illegal (assuming that message has type string):\n\u0026gt;\u0026gt;\u0026gt; message - 1 # Error \u0026gt;\u0026gt;\u0026gt; \u0026quot;Hello\u0026quot; / 123 # Error \u0026gt;\u0026gt;\u0026gt; message * \u0026quot;Hello\u0026quot; # Error \u0026gt;\u0026gt;\u0026gt; \u0026quot;15\u0026quot; + 2 # Error Interestingly, the + operator does work with strings, but for strings, the + operator represents concatenation, not addition. Concatenation means joining the two operands by linking them end-to-end. For example:\nfruit = \u0026quot;banana\u0026quot; baked_good = \u0026quot; nut bread\u0026quot; print(fruit + baked_good) The output of this program is banana nut bread. The space before the word nut is part of the string, and is necessary to produce the space between the concatenated strings.\nThe * operator also works on strings; it performs repetition. For example:\nprint('Fun' * 3) One of the operands has to be a string; the other has to be an integer.\nOn one hand, this interpretation of + and * makes sense by analogy with addition and multiplication. Just as 4*3 is equivalent to 4+4+4, we expect \u0026quot;Fun\u0026quot;*3 to be the same as \u0026quot;Fun\u0026quot;+\u0026quot;Fun\u0026quot;+\u0026quot;Fun\u0026quot;, and it is.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s10/",
	"title": "Input",
	"tags": [],
	"description": "",
	"content": "There is a built-in function in Python for getting input from the user:\nn = input(\u0026quot;Please enter your name: \u0026quot;) print(\u0026quot;Hi, \u0026quot; + n) When you run this script, the program pauses to receive user input. (In this ebook, the program will pop up a separate window to receive your input. In IDLE, the input prompt will appear in the shell window.) The user of the program can enter the name, and when this happens the text that has been entered is assigned to the variable n. This variable is then printed by the print function in line 2.\nEven if you asked the user to enter their age, you would get back a string like \u0026quot;17\u0026quot;. It would be your job, as the programmer, to convert that string into a int or a float, using the int or float converter functions we saw earlier.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s11/",
	"title": "Composition",
	"tags": [],
	"description": "",
	"content": "So far, we have looked at the elements of a program — variables, expressions, statements, and function calls — in isolation, without talking about how to combine them.\nOne of the most useful features of programming languages is their ability to take small building blocks and compose them into larger chunks.\nFor example, we know how to get the user to enter some input, we know how to convert the string we get into a float, we know how to write a complex expression, and we know how to print values. Let’s put these together in a small four-step program that asks the user to input a value for the radius of a circle, and then computes the area of the circle from the formula\nArea = pi * r^2\nFirstly, we’ll do the four steps one at a time:\nresponse = input(\u0026quot;What is your radius? \u0026quot;) r = float(response) area = 3.14159 * r**2 print(\u0026quot;The area is \u0026quot; + str(area)) Notice that we have to convert the value of the variable area to a string before we can print it. If we don’t, we get an error:\nresponse = input(\u0026quot;What is your radius? \u0026quot;) r = float(response) area = 3.14159 * r**2 print(\u0026quot;The area is \u0026quot; + area) We get a runtime error in the above program because Python doesn’t know how to “add” a string and a float. We need to convert the float to a string before we can add (that is, concatenate) it to the string \u0026quot;The area is \u0026quot;.\nNow let’s compose the first two lines into a single line of code, and compose the second two lines into another line of code.\nr = float( input(\u0026quot;What is your radius? \u0026quot;) ) print(\u0026quot;The area is \u0026quot; + str(3.14159 * r**2)) If we really wanted to be tricky, we could write it all in one statement:\nprint(\u0026quot;The area is \u0026quot; + str(3.14159 * float(input(\u0026quot;What is your radius? \u0026quot;))**2)) Such compact code may not be most understandable for humans, but it does illustrate how we can compose bigger chunks from our building blocks.\nIf you’re ever in doubt about whether to compose code or fragment it into smaller steps, try to make it as simple as you can for the human to follow. My choice would be the first case above, with four separate steps.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s12/",
	"title": "The modulus operator",
	"tags": [],
	"description": "",
	"content": "The modulus operator works on integers (and integer expressions) and gives the remainder when the first number is divided by the second. In Python, the modulus operator is a percent sign (%). The syntax is the same as for other operators. It has the same precedence as the multiplication operator.\n\u0026gt;\u0026gt;\u0026gt; q = 7 // 3 # This is integer division operator \u0026gt;\u0026gt;\u0026gt; print(q) 2 \u0026gt;\u0026gt;\u0026gt; r = 7 % 3 \u0026gt;\u0026gt;\u0026gt; print(r) 1 So 7 divided by 3 is 2 with a remainder of 1.\nThe modulus operator turns out to be surprisingly useful. For example, you can check whether one number is divisible by another—if x\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;%\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;y is zero, then x is divisible by y.\nAlso, you can extract the right-most digit or digits from a number. For example, x\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;%\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;10 yields the right-most digit of x (in base 10). Similarly x\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;%\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;100 yields the last two digits.\nIt is also extremely useful for doing conversions, say from seconds, to hours, minutes and seconds. So let’s write a program to ask the user to enter some seconds, and we’ll convert them into hours, minutes, and remaining seconds.\n# ask user for the total number of seconds totalSecs = int(input(\u0026quot;How many seconds, in total?\u0026quot;)) # compute hours, minutes, seconds hours = totalSecs // 3600 secsStillRemaining = totalSecs % 3600 minutes = secsStillRemaining // 60 secsFinallyRemaining = secsStillRemaining % 60 # print the result print(\u0026quot;Hrs=\u0026quot; + str(hours) + \u0026quot; Mins=\u0026quot; + str(minutes) + \u0026quot; Secs=\u0026quot; + str(secsFinallyRemaining)) We see a neat little trick in the above program: the print statement in line 11 extends over into line 12. This is OK—when the program runs, Python will figure out that the statement on line 11 hasn’t finished yet and continues onto line 12. It’s usually a good idea to indent your second line a bit so that’s it’s clear to a human that the previous line hasn’t finished yet.\nWe also see how comments make a long program easier for a human to read. Get in the habit of writing comments as part of your programs!\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_02/s13/",
	"title": "Exercises",
	"tags": [],
	"description": "",
	"content": "Work in the jupyter notebook!\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_03/",
	"title": "Program Flow",
	"tags": [],
	"description": "",
	"content": "Using Libraries There are many modules in Python that provide very powerful features that we can use in our own programs. Some of these can send email, or fetch web pages. The one use at in this chapter allows us to create turtles and use them to draw shapes and patterns.\nThe turtles are fun, but the real purpose of the chapter is to teach ourselves a little more Python, and to develop our abilities to think like computer scientists. Most of the Python covered here will be explored in more depth later.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_03/s01/",
	"title": "Hello Turtles!",
	"tags": [],
	"description": "",
	"content": "Our first turtle program To use the turtle library in a Collab Jupyter notebook, we start by installing the library.\nYou will have to execute this cell every time you restart a new session.\n!pip install ColabTurtlePlus With the turtle library, we can draw by moving a virtual turtle around the screen. Let’s write a couple of lines of Python program to create a new turtle and start drawing a rectangle. (We’ll call the variable that refers to our first turtle shelly, but you can choose any name you want so long as it follows the Python variable naming rules from the previous chapter).\nHere is a first program we will analyze together:\nimport ColabTurtlePlus.Turtle as turtle\t# Imports the turtle library turtle.clearscreen() # Remove drawings from previous runs. turtle.setup(200, 100) # Sets the dimensions of the viewing window. shelly = turtle.Turtle() # Create a turtle, assign to shelly shelly.forward(50) # Tell shelly to move forward by 50 units shelly.left(90) # Tell shelly to turn left by 90 degrees shelly.forward(30) # Complete the second side of a rectangle Here are a couple of things we will need to understand about this program. (Do not worry if you do not understand them all now— we will cover them in more detail as we work through the book.)\nThe first line, import ColabTurtlePlus.Turtle as turtle, tells Python to load a module (we also this a library) named ColabTurtlePlus.Turtle that will be used in this notebook with the name turtle.\nThe turtle library defines a new type, Turtle that has operations like forward() for moving the a turtle. The dot notation turtle.Turtle means “The Turtle type that is defined within the turtle module”. (Remember that Python is case sensitive, so the module name, with a lowercase t, is different from the type Turtle.)\nThe next line clears the screen to remove drawings from previous runs with turtle.clearscreen() and set the dimensions to a size that is big enough for the drawing with turtle.setup(200,100).\nThen, shelly = turtle.Turtle() creates a new turtle and assigns it to the variable shelly.\nNow we are ready to draw using the turtle:\nshelly.forward(50) # Tell shelly to move forward by 50 units shelly.left(90) # Tell shelly to turn left by 90 degrees shelly.forward(30) # Complete the second side of a rectangle These lines instruct the Turtle object that the shelly variable references to move, and to turn. We do this by invoking, or calling, methods of that Turtle object. Methods are functions defined by the turtle library that can be called on Turtle objects. Here, the forward method takes a parameter that gives the distance, and the Turtle object will move that distance in the direction it is pointing. The left method causes the Turtle object to turn so it is now facing a new direction.\nRunning the program produces the output below.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_03/s02/",
	"title": "Color",
	"tags": [],
	"description": "",
	"content": "An object can have various methods — things it can do — and it can also have attributes (sometimes called properties). These are like internal variables that can be used to keep track of the state of the object.\nFor the Turtle objects, we can\u0026rsquo;t manipulate the internal state directly, but instead can invoke methods on a Turtle object to change its internal state. We\u0026rsquo;ve already seen this with the facing direction in the last part — something must be keeping track of the direction the Turtle object is facing since it moves in a different forward direction after we called shelly.left(90).\nThe color of the turtle, the width of its pen, the position of the turtle within the window, which way it is facing, and so on are all part of its current state. Similarly, the window has a background color.\nThe example below produces a nicer drawing by using the color and pensize methods to change the state of the Turtle object, and the bgcolor method to change the state of the canvas.\nimport ColabTurtlePlus.Turtle as turtle turtle.clearscreen() turtle.setup(200,200) turtle.bgcolor(\u0026#34;lightgreen\u0026#34;) # Set the background color shelly = turtle.Turtle() shelly.color(\u0026#34;blue\u0026#34;)\t# Tell shelly to change her color shelly.pensize(3) # Tell shelly to set her pen width shelly.forward(50) shelly.left(120) shelly.forward(50) Running the program produces the output below. Notice the chages in the size of the drawing area, color of the background and lines, and the thickness of the lines.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_04/s02/",
	"title": "Conditionals",
	"tags": [],
	"description": "",
	"content": "Programs get really interesting when we can test conditions and change the program behavior depending on the outcome of the tests. That’s what this chapter is about.\nBoolean values and expressions A Boolean value is either true or false. It is named after the British mathematician, George Boole, who first formulated Boolean algebra — some rules for reasoning about and combining these values. This is the basis of all modern computer logic.\nIn Python, the two Boolean values are True and False (the capitalization must be exactly as shown), and the Python type is bool.\n\u0026gt;\u0026gt;\u0026gt; type(True) \u0026lt;class \u0026amp;#39;bool\u0026amp;#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(true) Traceback (most recent call last): File \u0026quot;\u0026lt;pyshell#3\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; type(true) NameError: name \u0026amp;#39;true\u0026amp;#39; is not defined \u0026lt;/pre\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; A **Boolean expression** is an expression that evaluates to produce a result which is a Boolean value. For example, the operator ```==``` tests if two values are equal. It produces (or *yields*) a Boolean value:    5 == (3 + 2) # Is five equal 5 to the result of 3 + 2? True 5 == 6 False j = \u0026ldquo;hel\u0026rdquo; j + \u0026ldquo;lo\u0026rdquo; == \u0026ldquo;hello\u0026rdquo; True\n    In the first statement, the two operands evaluate to equal values, so the expression evaluates to ```True```; in the second statement, 5 is not equal to 6, so we get ```False```. The ```==``` operator is one of six common **comparison operators** which all produce a ```bool``` result; here are all six: x == y # Produce True if \u0026hellip; x is equal to y x != y # \u0026hellip; x is not equal to y x \u0026gt; y # \u0026hellip; x is greater than y x \u0026lt; y # \u0026hellip; x is less than y x \u0026gt;= y # \u0026hellip; x is greater than or equal to y x \u0026lt;= y # \u0026hellip; x is less than or equal to y\n Although these operations are probably familiar, the Python symbols are different from the mathematical symbols. A common error is to use a single equal sign (```=```) instead of a double equal sign (```==```). Remember that ```=``` is an assignment operator and ```==``` is a comparison operator. Also, there is no such thing as ```=\u0026lt;``` or ```=\u0026gt;```. Like any other types we\u0026amp;#8217;ve seen so far, Boolean values can be assigned to variables, printed, etc. age = 18 oldEnoughToGetDriversLicense = age \u0026gt;= 16 print(oldEnoughToGetDriversLicense)\n ## Logical operators There are three **logical operators**, ```and```, ```or```, and ```not```, that allow us to build more complex Boolean expressions from simpler Boolean expressions. The semantics (meaning) of these operators is similar to their meaning in English. For example, ```x \u0026gt; 0 and x \u0026lt; 10``` produces ```True``` only if ```x``` is greater than 0 *and* at the same time, x is less than 10. ```n % 2 == 0 or n % 3 == 0``` is ```True``` if *either* of the conditions is ```True```, that is, if the number ```n``` is divisible by 2 *or* it is divisible by 3. What do you think happens if ```n``` is divisible by both 2 and by 3 at the same time? Will the expression yield ```True``` or ```False```? Let\u0026amp;#8217;s try it: n = 6 print(n % 2 == 0 or n % 3 == 0)\n Finally, the ```not``` operator negates a Boolean value, so ```not (x \u0026gt; y)``` is ```True``` if ```(x \u0026gt; y)``` is ```False```, that is, if ```x``` is less than or equal to ```y```. The expression on the left of the ```or``` operator is evaluated first: if the result is ```True```, Python does not (and need not) evaluate the expression on the right \u0026amp;#8212; this is called *short-circuit evaluation*. Similarly, for the ```and``` operator, if the expression on the left yields ```False```, Python does not evaluate the expression on the right. In this way, there are no unnecessary evaluations. ## Truth Tables A truth table is a small table that allows us to list all the possible inputs, and to give the results for the logical operators. Because the ```and``` and ```or``` operators each have two operands, there are only four rows in a truth table that describes the semantics of ```and```. \u0026lt;div\u0026gt;\u0026lt;table border=\u0026quot;1\u0026quot; class=\u0026quot;docutils\u0026quot;\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col width=\u0026quot;32%\u0026quot; /\u0026gt; \u0026lt;col width=\u0026quot;32%\u0026quot; /\u0026gt; \u0026lt;col width=\u0026quot;36%\u0026quot; /\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead valign=\u0026quot;bottom\u0026quot;\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;a\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;b\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;a and b\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;tr class=\u0026quot;row-even\u0026quot;\u0026gt;\u0026lt;td\u0026gt;False\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;False\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;False\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;td\u0026gt;False\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;True\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;False\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-even\u0026quot;\u0026gt;\u0026lt;td\u0026gt;True\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;False\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;False\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;td\u0026gt;True\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;True\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;True\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; In a Truth Table, we sometimes use T and F as shorthand for the two Boolean values: here is the truth table describing ```or```: \u0026lt;div\u0026gt;\u0026lt;table border=\u0026quot;1\u0026quot; class=\u0026quot;docutils\u0026quot;\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col width=\u0026quot;23%\u0026quot; /\u0026gt; \u0026lt;col width=\u0026quot;23%\u0026quot; /\u0026gt; \u0026lt;col width=\u0026quot;54%\u0026quot; /\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead valign=\u0026quot;bottom\u0026quot;\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;a\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;b\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;a or b\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;tr class=\u0026quot;row-even\u0026quot;\u0026gt;\u0026lt;td\u0026gt;F\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;F\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;F\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;td\u0026gt;F\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;T\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;T\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-even\u0026quot;\u0026gt;\u0026lt;td\u0026gt;T\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;F\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;T\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;td\u0026gt;T\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;T\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;T\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; The third logical operator, ```not```, only takes a single operand, so its truth table only has two rows: \u0026lt;div\u0026gt;\u0026lt;table border=\u0026quot;1\u0026quot; class=\u0026quot;docutils\u0026quot;\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col width=\u0026quot;33%\u0026quot; /\u0026gt; \u0026lt;col width=\u0026quot;67%\u0026quot; /\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead valign=\u0026quot;bottom\u0026quot;\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;a\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;not a\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;tr class=\u0026quot;row-even\u0026quot;\u0026gt;\u0026lt;td\u0026gt;F\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;T\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;td\u0026gt;T\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;F\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; ## Conditional execution In order to write useful programs, we almost always need the ability to check conditions and change the behavior of the program accordingly. **Conditional statements** give us this ability. The simplest form is the **if** statement: x = 8\nif x % 2 == 0: print(str(x)+\u0026rdquo; is even.\u0026quot;) print(\u0026ldquo;Did you know that 2 is the only even number that is prime?\u0026quot;) else: print(str(x)+\u0026rdquo; is odd.\u0026quot;) print(\u0026ldquo;Did you know that multiplying two odd numbers \u0026quot; + \u0026ldquo;always gives an odd result?\u0026quot;)\n Try changing the value of ```x``` in the above program, and see how the output changes. The Boolean expression after the ```if``` statement is called the **condition**. If it is true, then all the indented statements get executed. If not, then all the statements indented under the ```else``` clause get executed. Flowchart of an if statement with an else clause \u0026lt;img alt=\u0026quot;/pythonbook/images/flowchart_if_else.png\u0026quot; class=\u0026quot;last\u0026quot; src=\u0026quot;/pythonbook/images/flowchart_if_else.png\u0026quot; /\u0026gt; The syntax for an ```if``` statement looks like this: if BOOLEAN EXPRESSION: STATEMENTS_1 # Executed if condition evaluates to True else: STATEMENTS_2 # Executed if condition evaluates to False\n As with the function definition from the last chapter and other compound statements like ```for```, the ```if``` statement consists of a header line and a body. The header line begins with the keyword ```if``` followed by a *Boolean expression* and ends with a colon (:). The indented statements that follow are called a **block**. The first unindented statement marks the end of the block. Each of the statements inside the first block of statements are executed in order if the Boolean expression evaluates to ```True```. The entire first block of statements is skipped if the Boolean expression evaluates to ```False```, and instead all the statements indented under the ```else``` clause are executed. There is no limit on the number of statements that can appear under the two clauses of an ```if``` statement, but there has to be at least one statement in each block. Occasionally, it is useful to have a section with no statements (usually as a place keeper, or scaffolding, for code we haven\u0026amp;#8217;t written yet). In that case, we can use the ```pass``` statement, which does nothing except act as a placeholder. if True: # This is always True, pass # so this is always executed, but it does nothing else: pass\n ## Omitting the ```else``` clause Flowchart of an if statement with no else clause \u0026lt;img alt=\u0026quot;/pythonbook/images/flowchart_if_only.png\u0026quot; class=\u0026quot;last\u0026quot; src=\u0026quot;/pythonbook/images/flowchart_if_only.png\u0026quot; /\u0026gt; Another form of the ```if``` statement is one in which the ```else``` clause is omitted entirely. In this case, when the condition evaluates to ```True```, the statements are executed, otherwise the flow of execution continues to the statement after the ```if```. x = 36 if x \u0026lt; 0: print(\u0026ldquo;The negative number \u0026ldquo;+str(x)+\u0026rdquo; is not valid here.\u0026quot;) x = 42 print(\u0026ldquo;I\u0026rsquo;ve decided to use the number 42 instead.\u0026quot;) print(\u0026ldquo;The square root of \u0026ldquo;+str(x)+\u0026rdquo; is \u0026ldquo;+str(x**0.5))\n In this case, the print function that outputs the square root is the one after the ```if``` block. As the code is originally written, the condition of the ```if``` statement is ```False```, so the block of code inside the ```if``` block gets skipped. Change the value of ```x``` to something negative and run it again to see the difference. Python terminology Python documentation sometimes uses the term **suite** of statements to mean what we have called a *block* here. They mean the same thing, and since most other languages and computer scientists use the word *block*, we\u0026amp;#8217;ll stick with that. \u0026lt;p class=\u0026quot;last\u0026quot;\u0026gt;Notice too that ```else``` is not a statement. The ```if``` statement has two *clauses*, one of which is the (optional) ```else``` clause. ## Chained conditionals Sometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a **chained conditional**: if x \u0026lt; y: STATEMENTS_A elif x \u0026gt; y: STATEMENTS_B else: STATEMENTS_C\n Flowchart of this chained conditional \u0026lt;img alt=\u0026quot;/pythonbook/images/flowchart_chained_conditional.png\u0026quot; class=\u0026quot;last\u0026quot; src=\u0026quot;/pythonbook/images/flowchart_chained_conditional.png\u0026quot; /\u0026gt; \u0026lt;/div\u0026gt; ```elif``` is an abbreviation of ```else if```. Again, exactly one branch will be executed. There is no limit of the number of ```elif``` statements but only a single (and optional) final ```else``` statement is allowed and it must be the last branch in the statement: if choice == \u0026ldquo;a\u0026rdquo;: function_one() elif choice == \u0026ldquo;b\u0026rdquo;: function_two() elif choice == \u0026ldquo;c\u0026rdquo;: function_three() else: print(\u0026ldquo;Invalid choice.\u0026quot;)\n Each condition is checked in order. If the first is false, the next is checked, and so on. If one of them is true, the corresponding branch executes, and the statement ends. Even if more than one condition is true, only the first true branch executes. ## Nested conditionals One conditional can also be **nested** within another. (It is the same theme of composability, again!) We could have written the previous example as follows: Flowchart of this nested conditional \u0026lt;img alt=\u0026quot;/pythonbook/images/flowchart_nested_conditional.png\u0026quot; class=\u0026quot;last\u0026quot; src=\u0026quot;/pythonbook/images/flowchart_nested_conditional.png\u0026quot; /\u0026gt; \u0026lt;/div\u0026gt; if x \u0026lt; y: STATEMENTS_A else: if x \u0026gt; y: STATEMENTS_B else: STATEMENTS_C\n The outer conditional contains two branches. The second branch contains another ```if``` statement, which has two branches of its own. Those two branches could contain conditional statements as well. Although the indentation of the statements makes the structure apparent, nested conditionals very quickly become difficult to read. In general, it is a good idea to avoid them when we can. Logical operators often provide a way to simplify nested conditional statements. For example, we can rewrite the following code using a single conditional: if 0 \u0026lt; x: # Assume x is an int here if x \u0026lt; 10: print(\u0026ldquo;x is a positive single digit.\u0026quot;)\n The ```print``` function is called only if we make it past both the conditionals, so instead of the above which uses two ```if``` statements each with a simple condition, we could make a more complex condition using the ```and``` operator. Now we only need a single ```if``` statement: if 0 \u0026lt; x and x \u0026lt; 10: # Assume x is an int here print(\u0026ldquo;x is a positive single digit.\u0026quot;)\n ## The ```return``` statement The ```return``` statement, with or without a value, depending on whether the function is fruitful or void, allows us to terminate the execution of a function before (or when) we reach the end. One reason to use an *early return* is if we detect an error condition: def print_square_root(x): if x \u0026lt;= 0: print(\u0026ldquo;Positive numbers only, please.\u0026quot;) return result = x**0.5 print(\u0026ldquo;The square root of \u0026ldquo;+str(x)+\u0026rdquo; is \u0026ldquo;+str(result))\nprint_square_root(16) print_square_root(-4)\n The function ```print_square_root``` has a parameter named ```x```. The first thing it does is check whether ```x``` is less than or equal to 0, in which case it displays an error message and then uses ```return``` to exit the function. The flow of execution immediately returns to the caller, and the remaining lines of the function are not executed. ## Logical opposites Each of the six relational operators has a logical opposite: for example, suppose we can get a driver\u0026amp;#8217;s licence when our age is greater or equal to 16, we can *not* get the driver\u0026amp;#8217;s licence when we are less than 16. Notice that the opposite of ```\u0026gt;=``` is ```\u0026lt;```. \u0026lt;div\u0026gt;\u0026lt;table border=\u0026quot;1\u0026quot; class=\u0026quot;docutils\u0026quot;\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col width=\u0026quot;33%\u0026quot; /\u0026gt; \u0026lt;col width=\u0026quot;67%\u0026quot; /\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead valign=\u0026quot;bottom\u0026quot;\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;operator\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026quot;head\u0026quot;\u0026gt;logical opposite\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;tr class=\u0026quot;row-even\u0026quot;\u0026gt;\u0026lt;td\u0026gt;==\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;!=\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;td\u0026gt;!=\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;==\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-even\u0026quot;\u0026gt;\u0026lt;td\u0026gt;\u0026lt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026gt;=\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;td\u0026gt;\u0026lt;=\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-even\u0026quot;\u0026gt;\u0026lt;td\u0026gt;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;=\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;row-odd\u0026quot;\u0026gt;\u0026lt;td\u0026gt;\u0026gt;=\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; Understanding these logical opposites allows us to sometimes get rid of ```not``` operators. ```not``` operators are often quite difficult to read in computer code, and our intentions will usually be clearer if we can eliminate them. For example, if we wrote this Python: if not (age \u0026gt;= 17): print(\u0026ldquo;Hey, you are too young to get a driver\u0026rsquo;s licence!\u0026quot;)\n it would probably be clearer to use the simplification laws, and to write instead: if age \u0026lt; 17: print(\u0026ldquo;Hey, you are too young to get a driver\u0026rsquo;s licence!\u0026quot;)\n Two powerful simplification laws (called de Morgan\u0026amp;#8217;s laws) that are often helpful when dealing with complicated Boolean expressions are: not (x and y) == (not x) or (not y) not (x or y) == (not x) and (not y)\n For example, suppose we can slay the dragon only if our magic lightsabre sword is charged to 90% or higher, and we have 100 or more energy units in our protective shield. We find this fragment of Python code in the game: if not ((sword_charge \u0026gt;= 0.90) and (shield_energy \u0026gt;= 100)): print(\u0026ldquo;Your attack has no effect, the dragon fries you to a crisp!\u0026quot;) else: print(\u0026ldquo;The dragon crumples in a heap. You rescue the princess!\u0026quot;)\n de Morgan\u0026amp;#8217;s laws together with the logical opposites would let us rework the condition in a (perhaps) easier to understand way like this: if (sword_charge \u0026lt; 0.90) or (shield_energy \u0026lt; 100): print(\u0026ldquo;Your attack has no effect, the dragon fries you to a crisp!\u0026quot;) else: print(\u0026ldquo;The dragon crumples in a heap. You rescue the princess!\u0026quot;)\n We could also get rid of the ```not``` by swapping around the ```then``` and ```else``` parts of the conditional. So here is a third version, also equivalent: if (sword_charge \u0026gt;= 0.90) and (shield_energy \u0026gt;= 100): print(\u0026ldquo;The dragon crumples in a heap. You rescue the princess!\u0026quot;) else: print(\u0026ldquo;Your attack has no effect, the dragon fries you to a crisp!\u0026quot;)\n This version is probably the best of the three, because it very closely matches the initial English statement. Clarity of our code (for other humans), and making it easy to see that the code does what was expected should always be a high priority. As our programming skills develop we\u0026amp;#8217;ll find we have more than one way to solve any problem. So good programs are *designed*. We make choices that favour clarity, simplicity, and elegance. The job title *software architect* says a lot about what we do \u0026amp;#8212; we are *architects* who engineer our products to balance beauty, functionality, simplicity and clarity in our creations. Tip Once our program works, we should play around a bit trying to polish it up. Write good comments. Think about whether the code would be clearer with different variable names. Could we have done it more elegantly? Should we rather use a function? Can we simplify the conditionals? We think of our code as our creation, our work of art! We make it great. ## Type conversion We\u0026amp;#8217;ve had a first look at this in an earlier chapter. Seeing it again won\u0026amp;#8217;t hurt! Many Python types come with a built-in function that attempts to convert values of another type into its own type. The ```int``` function, for example, takes any value and converts it to an integer, if possible, or complains otherwise:    int(\u0026ldquo;32\u0026rdquo;) 32 int(\u0026ldquo;Hello\u0026rdquo;) Traceback (most recent call last): File \u0026ldquo;\u0026lt;pyshell#6\u0026gt;\u0026rdquo;, line 1, in  int(\u0026ldquo;hello\u0026rdquo;) ValueError: invalid literal for int() with base 10: 'hello'\n    ```int``` can also convert floating-point values to integers, but remember that it truncates the fractional part:    int(-2.3) -2 int(3.99999) 3 int(\u0026ldquo;42\u0026rdquo;) 42 int(1.0) 1\n    The ```float``` function converts integers and strings to floating-point numbers:    float(32) 32.0 float(\u0026ldquo;3.14159\u0026rdquo;) 3.14159 float(1) 1.0\n    It may seem odd that Python distinguishes the integer value ```1``` from the floating-point value ```1.0```. They may represent the same number, but they belong to different types. The reason is that they are represented differently inside the computer. The ```str``` function converts any argument given to it to type ```string```:    str(32) '32' str(3.14149) '3.14149' str(True) 'True' str(true) Traceback (most recent call last): File \u0026ldquo;\u0026lt;pyshell#7\u0026gt;\u0026rdquo;, line 1, in  str(true) NameError: name 'true' is not defined\n    ```str``` will work with any value and convert it into a string. As mentioned earlier, ```True``` is Boolean value; ```true``` is just an ordinary variable name, and is not defined here, so we get an error. ## Boolean functions Functions can return Boolean values, which is often convenient for hiding complicated tests inside functions. For example: def is_divisible(x, y): \u0026quot;\u0026rdquo;\u0026rdquo; Test if x is exactly divisible by y \u0026quot;\u0026rdquo;\u0026rdquo; if x % y == 0: return True else: return False\nprint(is_divisible(10,5)) # should print True print(is_divisible(10,7)) # should print False\n It is common to give **Boolean functions** names that sound like yes/no questions. ```is_divisible``` returns either ```True``` or ```False``` to indicate whether the ```x``` is or is not divisible by ```y```. We can make the function more concise by taking advantage of the fact that the condition of the ```if``` statement is itself a Boolean expression. We can return it directly, avoiding the ```if``` statement altogether: def is_divisible(x, y): \u0026quot;\u0026rdquo;\u0026rdquo; Test if x is exactly divisible by y \u0026quot;\u0026rdquo;\u0026rdquo; return x % y == 0\nprint(is_divisible(10,5)) # should print True print(is_divisible(10,7)) # should print False\n Boolean functions are often used in conditional statements: if is_divisible(x, y): \u0026hellip; # Do something \u0026hellip; else: \u0026hellip; # Do something else \u0026hellip;\n It might be tempting to write something like: if is_divisible(x, y) == True:\n but the extra comparison is unnecessary. "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_05/s03/",
	"title": "Iteration",
	"tags": [],
	"description": "",
	"content": "Computers are often used to automate repetitive tasks. Repeating identical or similar tasks without making errors is something that computers do well and people do poorly.\nRepeated execution of a set of statements is called iteration. Because iteration is so common, Python provides several language features to make it easier. We’ve already seen the for statement: this the the form of iteration you’ll likely be using most often. But in this chapter we’ve going to look at the while statement: another way to have your program do iteration, useful in slightly different circumstances.\nBefore we do that, let’s just review a few ideas\u0026hellip;\nAssignment As we have mentioned previously, it is legal to make more than one assignment to the same variable. A new assignment makes an existing variable refer to a new value (and stop referring to the old value).\nairtime_remaining = 15 print(airtime_remaining) airtime_remaining = 7 print(airtime_remaining) The first time airtime_remaining is printed, its value is 15, and the second time, its value is 7.\nIt is especially important to distinguish between an assignment statement and a Boolean expression that tests for equality. Because Python uses the equal token (=) for assignment, it is tempting to interpret a statement like a = b as a Boolean test. Unlike mathematics, it is not! Remember that the Python token for the equality operator is ==.\nNote too that an equality test is symmetric, but assignment is not. For example, if a == 7 then 7 == a. But in Python, the statement a = 7 is legal and 7 = a is not.\nIn Python, an assignment statement can make two variables equal, but because further assignments can change either of them, they don’t have to stay that way:\na = 5 b = a # After executing this line, a and b are now equal print(\u0026quot;a=\u0026quot;+str(a)+\u0026quot; b=\u0026quot;+str(b)) a = 3 # After executing this line, a and b are no longer equal print(\u0026quot;a=\u0026quot;+str(a)+\u0026quot; b=\u0026quot;+str(b)) Line 4 changes the value of a but does not change the value of b, so they are no longer equal. Some people also think that variable was an unfortunate word to choose, and instead we should have called them assignables. Python chooses to follow common terminology and token usage, also found in languages like C, C++, Java, and C#, so we use the tokens = for assignment, == for equality, and we talk of variables.\nUpdating variables When an assignment statement is executed, the right-hand side expression (i.e. the expression that comes after the assignment token) is evaluated first. This produces a value. Then the assignment is made, so that the variable on the left-hand side now refers to the new value.\nOne of the most common forms of assignment is an update, where the new value of the variable depends on its old value. Deduct 40 cents from my airtime balance, or add one run to the scoreboard.\nn = 5 n = 3 * n + 1 print(n) Line 2 means get the current value of n, multiply it by three and add one, and assign the answer to n, thus making n refer to the value. So after executing the two lines above, n will point/refer to the integer 16.\nIf you try to get the value of a variable that has never been assigned to, you’ll get an error:\n\u0026gt;\u0026gt;\u0026gt; w = x + 1 Traceback (most recent call last): File \u0026quot;\u0026amp;lt;pyshell#0\u0026gt;\u0026quot;, line 1, in \u0026amp;lt;module\u0026gt; w=x+1 NameError: name \u0026amp;#39;x\u0026amp;#39; is not defined Before you can update a variable, you have to initialize it to some starting value, usually with a simple assignment:\nruns_scored = 0 ... runs_scored = runs_scored + 1 This sort of assignment — updating a variable by adding 1 to it — is very common. It is called an increment of the variable; subtracting 1 is called a decrement. Sometimes programmers also talk about bumping a variable, which means the same as incrementing it by 1.\nThe for loop revisited Recall that the for loop processes each item in a list. Each item in turn is (re-)assigned to the loop variable, and the body of the loop is executed. We saw this example in an earlier chapter:\nfor f in [\u0026quot;Joe\u0026quot;, \u0026quot;Zoe\u0026quot;, \u0026quot;Brad\u0026quot;, \u0026quot;Angelina\u0026quot;, \u0026quot;Zuki\u0026quot;, \u0026quot;Thandi\u0026quot;, \u0026quot;Paris\u0026quot;]: invitation = \u0026quot;Hi \u0026quot; + f + \u0026quot;. Please come to my party on Saturday!\u0026quot; print(invitation)\u0026lt;/textarea\u0026gt; Running through all the items in a list is called traversing the list, or traversal.\nLet us write a function now to sum up all the elements in a list of numbers. Do this by hand first, and try to isolate exactly what steps you take. You’ll find you need to keep some “running total” of the sum so far, either on a piece of paper, in your head, or in your calculator. Remembering things from one step to the next is precisely why we have variables in a program: so we’ll need some variable to remember the “running total”. It should be initialized with a value of zero, and then we need to traverse the items in the list. For each item, we’ll want to update the running total by adding the next number to it.\ndef mysum(xs): \u0026quot;\u0026quot;\u0026quot; Sum all the numbers in the list xs, and return the total. \u0026quot;\u0026quot;\u0026quot; running_total = 0 for x in xs: running_total = running_total + x return running_total # Add tests like these to your test suite ... print(mysum([1, 2, 3, 4])) # should be 10 print(mysum([1.25, 2.5, 1.75])) # should be 5.5 print(mysum([1, -2, 3])) # should be 2 print(mysum([ ])) # should be 0 print(mysum(range(11))) # should be 0+1+2+...+10 = 55\u0026lt;/textarea\u0026gt; The while statement Here is a fragment of code that demonstrates the use of the while statement:\ndef sum_to(n): \u0026quot;\u0026quot;\u0026quot; Return the sum of 1+2+3+...+n \u0026quot;\u0026quot;\u0026quot; ss = 0 v = 1 while v \u0026lt;= n: ss = ss + v v = v + 1 return ss # For your test suite print(sum_to(4)) print(sum_to(1000))\u0026lt;/textarea\u0026gt; You can almost read the while statement as if it were English. It means, while v is less than or equal to n, continue executing the body of the loop. Within the body, each time, increment v. When v passes n, return your accumulated sum.\nMore formally, here is precise flow of execution for a while statement:\nEvaluate the condition at line 5, yielding a value which is either ```False``` or ```True```. If the value is ```False```, exit the ```while``` statement and continue execution at the next statement (line 8 in this case). If the value is ```True```, execute each of the statements in the body (lines 6 and 7) and then go back to the ```while``` statement at line 5.  The body consists of all of the statements indented below the ```while``` keyword. Notice that if the loop condition is False the first time we get loop, the statements in the body of the loop are never executed.\nThe body of the loop should change the value of one or more variables so that eventually the condition becomes false and the loop terminates. Otherwise the loop will repeat forever, which is called an infinite loop. An endless source of amusement for computer scientists is the observation that the directions on shampoo, “lather, rinse, repeat”, are an infinite loop.\nIn the case here, we can prove that the loop terminates because we know that the value of n is finite, and we can see that the value of v increments each time through the loop, so eventually it will have to exceed n. In other cases, it is not so easy, even impossible in some cases, to tell if the loop will ever terminate.\nWhat you will notice here is that the while loop is more work for you — the programmer — than the equivalent for loop. When using a while loop one has to manage the loop variable yourself: give it an initial value, test for completion, and then make sure you change something in the body so that the loop terminates. By comparison, here is an equivalent function that uses for instead:\ndef sum_to(n): \u0026quot;\u0026quot;\u0026quot; Return the sum of 1+2+3+...+n \u0026quot;\u0026quot;\u0026quot; ss = 0 for v in range(n+1): ss = ss + v return ss print(sum_to(4)) print(sum_to(1000))\u0026lt;/textarea\u0026gt; Notice the slightly tricky call to the range function — we had to add one onto n, because range generates its list up to but excluding the value you give it. It would be easy to make a programming mistake and overlook this, but because we’ve made the investment of writing some unit tests, our test suite would have caught our error.\nSo why have two kinds of loop if for looks easier? This next example shows a case where we need the extra power that we get from the while loop.\nThe Collatz 3n + 1 sequence Let’s look at a simple sequence that has fascinated mathematicians for many years. They still cannot answer even quite simple questions about this.\nThe rule for creating the sequence is to start from some given n, and to generate the next term of the sequence from n, either by halving n (whenever n is even), or else by multiplying it by three and adding 1 (whenever n is odd). The sequence terminates when n reaches 1.\nThis Python function captures that algorithm:\ndef seq_3n_plus_1(n): \u0026quot;\u0026quot;\u0026quot; Print the 3n+1 sequence from n, terminating when it reaches 1. \u0026quot;\u0026quot;\u0026quot; while n != 1: print(n, end=\u0026quot;, \u0026quot;) if n % 2 == 0: # n is even n = n // 2 else: # n is odd n = n * 3 + 1 print(n, end=\u0026quot;.\\n\u0026quot;) seq_3n_plus_1(3) seq_3n_plus_1(19) Notice first that the print function on line 6 has an extra argument end = \u0026quot;,\u0026quot;. This tells the print function to follow the printed string with whatever the programmer chooses (in this case, a comma followed by a space), instead of ending the line. So each time something is printed in the loop, it is printed on the same output line, with the numbers separated by commas. The call to print(n, end=\u0026quot;.\\n\u0026quot;) at line 11 after the loop terminates will then print the final value of n followed by a period and a newline character. (You’ll cover the \\n (newline character) in the next chapter).\nThe condition for continuing with this loop is n != 1, so the loop will continue running until it reaches its termination condition, (i.e. n == 1).\nEach time through the loop, the program outputs the value of n and then checks whether it is even or odd. If it is even, the value of n is divided by 2 using integer division. If it is odd, the value is replaced by n * 3 + 1. Try some examples to see how the sequence behaves for different inputs.\nSince n sometimes increases and sometimes decreases, there is no obvious proof that n will ever reach 1, or that the program terminates. For some particular values of n, we can prove termination. For example, if the starting value is a power of two, then the value of n will be even each time through the loop until it reaches 1. The previous example ends with such a sequence, starting with 16.\nSee if you can find a small starting number that needs more than a hundred steps before it terminates.\nParticular values aside, the interesting question was first posed by a German mathematician called Lothar Collatz: the Collatz conjecture (also known as the 3n + 1 conjecture), is that this sequence terminates for all positive values of n. So far, no one has been able to prove it or disprove it! (A conjecture is a statement that might be true, but nobody knows for sure.)\nThink carefully about what would be needed for a proof or disproof of the conjecture “All positive integers will eventually converge to 1 using the Collatz rules”. With fast computers we have been able to test every integer up to very large values, and so far, they have all eventually ended up at 1. But who knows? Perhaps there is some as-yet untested number which does not reduce to 1.\nYou’ll notice that if you don’t stop when you reach 1, the sequence gets into its own cyclic loop: 1, 4, 2, 1, 4, 2, 1, 4 \u0026hellip; So one possibility is that there might be other cycles that we just haven’t found yet.\nWikipedia has an informative article about the Collatz conjecture. There’s also a humorous take on the Collatz conjecture at http://imgs.xkcd.com/comics/collatz_conjecture.png. The sequence also goes under other names (Hailstone sequence, Wonderous numbers, etc.), and you’ll find out just how many integers have already been tested by computer, and found to converge!\nChoosing between ```for``` and ```while``` Use a for loop if you know, before you start looping, the maximum number of times that you’ll need to execute the body. For example, if you’re traversing a list of elements, you know that the maximum number of loop iterations you can possibly need is “all the elements in the list”. Or if you need to print the 12 times table, we know right away how many times the loop will need to run.\nSo any problem like “iterate this weather model for 1000 cycles”, or “search this list of words”, “find all prime numbers up to 10000” suggest that a for loop is best.\nBy contrast, if you are required to repeat some computation until some condition is met, and you cannot calculate in advance when (of if) this will happen, as we did in this 3n + 1 problem, you’ll need a while loop.\nWe call the first case **definite iteration** \u0026#8212; we know ahead of time some definite bounds for what is needed. The latter case is called **indefinite iteration** \u0026#8212; we\u0026#8217;re not sure how many iterations we\u0026#8217;ll need \u0026#8212; we cannot even establish an upper bound!   6.6. Tracing a program¶ To write effective computer programs, and to build a good conceptual model of program execution, a programmer needs to develop the ability to **trace** the execution of a computer program. Tracing involves becoming the computer and following the flow of execution through a sample program run, recording the state of all variables and any output the program generates after each instruction is executed. To understand this process, let’s trace the call to seq3np1(3) from the previous section. At the start of the trace, we have a variable, n (the parameter), with an initial value of 3. Since 3 is not equal to 1, the while loop body is executed. 3 is printed and 3 % 2 == 0 is evaluated. Since it evaluates to False, the else branch is executed and 3 * 3 + 1 is evaluated and assigned to n.\nTo keep track of all this as you hand trace a program, make a column heading on a piece of paper for each variable created as the program runs and another one for output. Our trace so far would look something like this:\nn output printed so far -- --------------------- 3 3, 10    Since ```10 != 1``` evaluates to ```True```, the loop body is again executed, and 10 is printed. ```10 % 2 == 0``` is true, so the ```if``` branch is executed and ```n``` becomes 5. By the end of the trace we have: n output printed so far -- --------------------- 3 3, 10 3, 10, 5 3, 10, 5, 16 3, 10, 5, 16, 8 3, 10, 5, 16, 8, 4 3, 10, 5, 16, 8, 4, 2 3, 10, 5, 16, 8, 4, 2, 1 3, 10, 5, 16, 8, 4, 2, 1.    Tracing can be a bit tedious and error prone (that\u0026#8217;s why we get computers to do this stuff in the first place!), but it is an essential skill for a programmer to have. Tracing a program is, of course, related to single-stepping through your code and being able to inspect the variables. Using the computer to single-step for you is less error prone and more convenient. Also, as your programs get more complex, they might execute many millions of steps before they get to the code that you’re really interested in, so manual tracing becomes impossible. Being able to set a breakpoint where you need one is far more powerful.\nWe’ve cautioned against chatterbox functions, but used them here. As we learn a bit more Python, we’ll be able to show you how to generate a list of values to hold the sequence, rather than having the function print them. Doing this would remove the need to have all these pesky print functions in the middle of our logic, and will make the function more useful.\n 6.7. Counting digits¶ The following function counts the number of decimal digits in a positive integer: def num_digits(n): count = 0 while n != 0: count = count + 1 n = n // 10 return count print(num_digits(731))\n pythonTool.lineNumberFlags['countingdigits_code'] = true; pythonTool.readOnlyFlags['countingdigits_code'] = false;   Run Pop Out Reset       \n  Trace the execution of this function call to convince yourself that it works.\nThis function demonstrates an important pattern of computation called a counter. The variable count is initialized to 0 and then incremented each time the loop body is executed. When the loop exits, count contains the result — the total number of times the loop body was executed, which is the same as the number of digits.\nA common mistake is to forget to initialize your counter before you start your loop. You’ll get a runtime error if you do that, like in the example below:\ndef num_digits(n): while n != 0: count = count + 1 n = n // 10 return count print(num_digits(731))\n pythonTool.lineNumberFlags['countingwitherror_code'] = true; pythonTool.readOnlyFlags['countingwitherror_code'] = false;   Run Pop Out Reset       \n  If we wanted to only count digits that are either 0 or 5, adding a conditional before incrementing the counter will do the trick:\ndef num_zero_and_five_digits(n): count = 0 while n  0: digit = n % 10 if digit == 0 or digit == 5: count = count + 1 n = n // 10 return count print(num_zero_and_five_digits(1055030250))\n pythonTool.lineNumberFlags['countingzerosandfives_code'] = true; pythonTool.readOnlyFlags['countingzerosandfives_code'] = false;   Run Pop Out Reset       \n  Confirm that num_zero_and_five_digits(1055030250) returns 7.\nNotice, however, that num_digits(0) appears to fail. Explain why. Do you think this is a bug in the code, or a bug in the specifications, or our expectations, or the tests?\n 6.8. Abbreviated assignment¶ Incrementing a variable is so common that Python provides an abbreviated syntax for it: count = 0 print(count) count += 1 print(count) count += 1 print(count)  pythonTool.lineNumberFlags['selfincrement_code'] = true; pythonTool.readOnlyFlags['selfincrement_code'] = false;   Run Pop Out Reset       \n  count += 1 is an abreviation for count = count + 1 . We pronounce the operator as “plus-equals”. The increment value does not have to be 1:\nn = 2 n += 5 print(n)  pythonTool.lineNumberFlags['selfadd_code'] = true; pythonTool.readOnlyFlags['selfadd_code'] = false;   Run Pop Out Reset       \n  There are similar abbreviations for -=, *=, /=, //= and %=:\nn = 2 n *= 5 print(n) # 2 * 5 - 10 n -= 4 print(n) # 10 - 4 - 6 n //= 2 print(n) # 6 // 2 - 3 n %= 2 print(n) # 3 % 2 - 1  pythonTool.lineNumberFlags['selfarith_code'] = true; pythonTool.readOnlyFlags['selfarith_code'] = false;   Run Pop Out Reset       \n   6.9. Tables¶ One of the things loops are good for is generating tables. Before computers were readily available, people had to calculate logarithms, sines and cosines, and other mathematical functions by hand. To make that easier, mathematics books contained long tables listing the values of these functions. Creating the tables was slow and boring, and they tended to be full of errors. When computers appeared on the scene, one of the initial reactions was, “This is great! We can use the computers to generate the tables, so there will be no errors.” That turned out to be true (mostly) but shortsighted. Soon thereafter, computers and calculators were so pervasive that the tables became obsolete.\nWell, almost. For some operations, computers use tables of values to get an approximate answer and then perform computations to improve the approximation. In some cases, there have been errors in the underlying tables, most famously in the table the Intel Pentium processor chip used to perform floating-point division.\nAlthough a log table is not as useful as it once was, it still makes a good example of iteration. The following program outputs a sequence of values in the left column and 2 raised to the power of that value in the right column:\nfor x in range(13): # Generate numbers 0 to 12 print(str(x)+\"\\t\"+str(2**x))  pythonTool.lineNumberFlags['powersof2table_code'] = true; pythonTool.readOnlyFlags['powersof2table_code'] = false;   Run Pop Out Reset       \n  The string \u0026quot;\\t\u0026quot; represents a tab character. The backslash character in \u0026quot;\\t\u0026quot; indicates the beginning of an escape sequence. Escape sequences are used to represent invisible characters like tabs and newlines. The sequence \\n represents a newline.\nAn escape sequence can appear anywhere in a string; in this example, the tab escape sequence is the only thing in the string. How do you think you represent a backslash in a string?\nAs characters and strings are displayed on the screen, an invisible marker called the cursor keeps track of where the next character will go. After a print function, the cursor normally goes to the beginning of the next line.\nThe tab character shifts the cursor to the right until it reaches one of the tab stops. Tabs are useful for making columns of text line up, as in the output of the previous program. Because of the tab characters between the columns, the position of the second column does not depend on the number of digits in the first column.\n 6.10. Two-dimensional tables¶ A two-dimensional table is a table where you read the value at the intersection of a row and a column. A multiplication table is a good example. Let\u0026#8217;s say you want to print a multiplication table for the values from 1 to 6. A good way to start is to write a loop that prints the multiples of 2, all on one line:\nfor i in range(1, 7): print(2 * i, end=\" \") print()  pythonTool.lineNumberFlags['multtablestep1_code'] = true; pythonTool.readOnlyFlags['multtablestep1_code'] = false;   Run Pop Out Reset       \n  Here we’ve used the range function, but made it start its sequence at 1. As the loop executes, the value of i changes from 1 to 6. When all the elements of the range have been assigned to i, the loop terminates. Each time through the loop, it displays the value of 2 * i, followed by three spaces.\nAgain, the extra end=\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;\u0026quot; argument in the print function suppresses the newline, and uses three spaces instead. After the loop completes, the call to print at line 3 finishes the current line, and starts a new line.\nSo far, so good. The next step is to encapsulate and generalize.\n 6.11. Encapsulation and generalization¶ Encapsulation is the process of wrapping a piece of code in a function, allowing you to take advantage of all the things functions are good for. Generalization means taking something specific, such as printing the multiples of 2, and making it more general, such as printing the multiples of any integer.\nThis function encapsulates the previous loop and generalizes it to print multiples of n:\ndef print_multiples(n): for i in range(1, 7): print(n * i, end=\" \") print() print_multiples(2) print_multiples(3) print_multiples(4)\n pythonTool.lineNumberFlags['multtablestep2_code'] = true; pythonTool.readOnlyFlags['multtablestep2_code'] = false;   Run Pop Out Reset       \n  To encapsulate, all we had to do was add the first line, which declares the name of the function and the parameter list. To generalize, all we had to do was replace the value 2 with the parameter n.\nBy now you can probably guess how to print a multiplication table — by calling print_multiples repeatedly with different arguments. In fact, we can use another loop:\ndef print_multiples(n): for i in range(1, 7): print(n * i, end=\" \") print() for i in range(1, 7): print_multiples(i)\n pythonTool.lineNumberFlags['multtablestep3_code'] = true; pythonTool.readOnlyFlags['multtablestep3_code'] = false;   Run Pop Out Reset       \n  Notice how similar this loop is to the one inside print_multiples. All we did was replace the print function with a function call. The output of this program is a multiplication table.\n 6.12. More encapsulation¶ To demonstrate encapsulation again, let\u0026#8217;s take the code from the last section and wrap it up in a function: def print_multiples(n): for i in range(1, 7): print(n * i, end=\" \") print() def print_mult_table(): for i in range(1, 7): print_multiples(i)\nprint_mult_table()\n pythonTool.lineNumberFlags['multtablefinal_code'] = true; pythonTool.readOnlyFlags['multtablefinal_code'] = false;   Run Pop Out Reset       \n  This process is a common development plan. We develop code by writing lines of code outside any function, or typing them in to the interpreter. When we get the code working, we extract it and wrap it up in a function.\nThis development plan is particularly useful if you don’t know how to divide the program into functions when you start writing. This approach lets you design as you go along.\n 6.13. Local variables¶ You might be wondering how we can use the same variable, ```i```, in both ```print_multiples``` and ```print_mult_table```. Doesn\u0026#8217;t it cause problems when one of the functions changes the value of the variable? The answer is no, because the i in print_multiples and the i in print_mult_table are not the same variable.\nVariables created inside a function definition are local; you can’t access a local variable from outside its home function. That means you are free to have multiple variables with the same name as long as they are not in the same function.\nPython examines all the statements in a function — if any of them assign a value to a variable, that is the clue that Python uses to make the variable a local variable.\nThe stack diagram for this program shows that the two variables named i are not the same variable. They can refer to different values, and changing one does not affect the other.\n The value of ```i``` in ```print_mult_table``` goes from 1 to 6. In the diagram it happens to be 3. The next time through the loop it will be 4. Each time through the loop, ```print_mult_table``` calls ```print_multiples``` with the current value of ```i``` as an argument. That value gets assigned to the parameter ```n```. Inside print_multiples, the value of i goes from 1 to 6. In the diagram, it happens to be 2. Changing this variable has no effect on the value of i in print_mult_table.\nIt is common and perfectly legal to have different local variables with the same name. In particular, names like i and j are used frequently as loop variables. If you avoid using them in one function just because you used them somewhere else, you will probably make the program harder to read.\nThe break statement The break statement is used to immediately leave the body of its loop. The next statement to be executed is the first one after the body:\nfor i in [12, 16, 17, 24, 29]: if i % 2 == 1: # If the number is odd break # ... immediately exit the loop print(i) print(\u0026quot;done\u0026quot;) The pre-test loop — standard loop behavior\nfor and while loops do their tests at the start, before executing any part of the body. They’re called pre-test loops, because the test happens before (pre) the body. break and return are our tools for adapting this standard behavior.\nOther flavors of loops\u0026lt; Sometimes we’d like to have the middle-test loop with the exit test in the middle of the body, rather than at the beginning or at the end. Or a post-test loop that puts its exit test as the last thing in the body. Other languages have different syntax and keywords for these different flavours, but Python just uses a combination of while and if condition: break to get the job done.\nA typical example is a problem where the user has to input numbers to be summed. To indicate that there are no more inputs, the user enters a special value, often the value -1, or the empty string. This needs a middle-exit loop pattern: input the next number, then test whether to exit, or else process the number:\nThe middle-test loop flowchart\ntotal = 0 while True: response = input(\u0026quot;Enter the next number. (Leave blank to end)\u0026quot;) if response == \u0026quot;\u0026quot;: break total += int(response) print(\u0026quot;The total of the numbers you entered is \u0026quot;+str(total)) Convince yourself that this fits the middle-exit loop flowchart: line 3 does some useful work, lines 4 and 5 can exit the loop, and if they don’t line 6 does more useful work before the next iteration starts.\nThe while bool-expr: uses the Boolean expression to determine whether to iterate again. True is a trivial Boolean expression, so while True: means always do the loop body again. This is a language idiom — a convention that most programmers will recognize immediately. Since the expression on line 2 will never terminate the loop, (it is a dummy test) the programmer must arrange to break (or return) out of the loop body elsewhere, in some other way (i.e. in lines 4 and 5 in this sample).\nSimilarly, by just moving the if condition: break to the end of the loop body we create a pattern for a post-test loop. Post-test loops are used when you want to be sure that the loop body always executes at least once (because the first test only happens at the end of the execution of the first loop body). This is useful, for example, if we want to play an interactive game against the user — we always want to play at least one game:\nwhile True: play_the_game_once() response = input(\u0026quot;Play again? (yes or no)\u0026quot;) if response != \u0026quot;yes\u0026quot;: break print(\u0026quot;Goodbye!\u0026quot;) Hint: Think about where you want the exit test to happen\nOnce you’ve recognized that you need a loop to repeat something, think about its terminating condition — when will I want to stop iterating? Then figure out whether you need to do the test before starting the first (and every other) iteration, or at the end of the first (and every other) iteration, or perhaps in the middle of each iteration. Interactive programs that require input from the user or read from files often need to exit their loops in the middle or at the end of an iteration, when it becomes clear that there is no more data to process, or the user doesn’t want to play our game anymore.\nThe continue statement This is a control flow statement that causes the program to immediately skip the processing of the rest of the body of the loop, for the current iteration. But the loop still carries on running for its remaining iterations:\nfor i in [12, 16, 17, 24, 29, 30]: if i % 2 == 1: # If the number is odd continue # Don't process it print(i) print(\u0026quot;done\u0026quot;) Functions A few times now, we have mentioned all the things functions are good for. By now, you might be wondering what exactly those things are. Here are some of them:\nCapturing your mental chunking. Breaking your complex tasks into sub-tasks, and giving the sub-tasks a meaningful name is a powerful mental technique. Look back at the example that illustrated the post-test loop: we assumed that we had a function called ```play_the_game_once```. This chunking allowed us to put aside the details of the particular game \u0026#8212; is it a card game, or noughts and crosses, or a role playing game \u0026#8212; and simply focus on one isolated part of our program logic \u0026#8212; letting the player choose whether they want to play again. Dividing a long program into functions allows you to separate parts of the program, debug them in isolation, and then compose them into a whole. Functions facilitate the use of iteration. Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it.  "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_03/s03/",
	"title": "More Turtles",
	"tags": [],
	"description": "",
	"content": "A Bale of Turtles Just like we can have many different integers in a program, we can have many Turtle objects. Each of them is called an instance. Methods can be called on each instance to change its state and make it move.\nimport ColabTurtlePlus.Turtle as turtle turtle.clearscreen() turtle.setup(200,200) turtle.bgcolor(\u0026#34;lightgreen\u0026#34;) tess = turtle.Turtle() # Create tess and set some attributes tess.color(\u0026#34;hotpink\u0026#34;) tess.pensize(5) alex = turtle.Turtle() # Create alex # Make tess draw an equilateral triangle tess.forward(80) tess.left(120) tess.forward(80) tess.left(120) tess.forward(80) tess.left(120) # Complete the triangle tess.right(180) # Turn tess around tess.forward(80) # Move her away from the origin # Make alex draw a square alex.forward(50) alex.left(90) alex.forward(50) alex.left(90) alex.forward(50) alex.left(90) alex.forward(50) alex.left(90) There are 360 degrees in a full circle. If we add up all the turns that a turtle makes, no matter what steps occurred between the turns, we can easily figure out if they add up to some multiple of 360. Since alex has turned 90 + 90 + 90 + 90 = 360 degrees, after all the turns he is facing in exactly the same direction as he was when he was first created. (Geometry conventions have 0 degrees facing to the right, and that is the case here too!)\nWe could have left out the last turn for alex, but if we are asked to draw a closed shape like a square or a rectangle, it is a good idea to complete all the turns and to leave the turtle back where it started, facing the same direction as it started in. This makes reasoning about the program and composing chunks of code into bigger programs easier.\nWe did the same with tess: she drew her triangle, and turned through a full 360 degrees. Then we turned her around and moved her aside.\nBlank lines are used to separate groups of movements by shape.The movements for tess were “draw the triangle” (lines 12-17) and then “move away from the origin” (lines 19 and 20).\nOne of the key uses for comments is to record our mental chunking, and big ideas. They’re not always explicit in the code.\nTwo turtles may not be enough for a herd. But the important idea is that the turtle module gives us a kind of factory that lets us create as many turtles as we need. Each instance has its own state and behavior.\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_05/s04/",
	"title": "Some Tips, Tricks, and Common Errors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_03/s04/",
	"title": "Loops",
	"tags": [],
	"description": "",
	"content": "The for Loop When we drew the square, it was quite tedious. We had to explicitly repeat the steps of moving and turning four times. If we were drawing a hexagon, an octogon, or a enneacontaenneagon (that\u0026rsquo;s a polygon with 99 sides!), it would have been worse.\nSo a basic building block of all programs is to be able to repeat some code, over and over again.\nPython’s for loop does this. Let’s say we have some friends, and we’d like to send them each an email inviting them to our party. We don’t quite know how to send email yet, so for the moment we’ll just print a message for each friend:\nfor f in [\u0026#34;Joe\u0026#34;,\u0026#34;Zoe\u0026#34;,\u0026#34;Brad\u0026#34;,\u0026#34;Angelina\u0026#34;,\u0026#34;Zuki\u0026#34;,\u0026#34;Thandi\u0026#34;,\u0026#34;Paris\u0026#34;]: invite = \u0026#34;Hi \u0026#34; + f + \u0026#34;. Please come to my party on Saturday!\u0026#34; print(invite) # more code can follow here ...  The variable f in the for statement at line 1 is called the loop variable. We could have chosen any other variable name instead.\n Lines 2 and 3 are the loop body. The loop body is always indented. The convention is to use 4 spaces of indentation for our loop bodies. The indentation determines exactly what statements are “in the body of the loop”.\n On each iteration or pass of the loop, first a check is done to see if there are still more items to be processed. If there are none left (this is called the terminating condition of the loop), the loop has finished. Program execution continues at the next statement after the loop body, (e.g. in this case the next statement below the comment in line 4).\n If there are items still to be processed, the loop variable is updated to refer to the next item in the list. This means, in this case, that the loop body is executed here 7 times, and each time f will refer to a different friend.\n At the end of each execution of the body of the loop, Python returns to the for statement, to see if there are more items to be handled, and to assign the next one to f.\n Execution of a for Loop As a program executes, the interpreter always keeps track of which statement is about to be executed. We call this the control flow, of the flow of execution of the program. When humans execute programs, they often use their finger to point to each statement in turn. So we could think of control flow as “Python’s moving finger”.\nControl flow until now has been strictly top to bottom, one statement at a time. The for loop changes this.\nControl flow is often easy to visualize and understand if we draw a flowchart. This shows the exact steps and logic of how the for statement executes.\n\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_03/s05/",
	"title": "Loopy Turtles",
	"tags": [],
	"description": "",
	"content": "Condensing our Turtle Program using Loops To draw a square we’d like to do the same thing four times — move the turtle, and turn left 90 degrees. We previously used 8 lines to have alex draw the four sides of a square.\nThis does exactly the same, but using just three lines with a for loop:\nimport turtle wn = turtle.Screen() # Set up the window and its attributes alex = turtle.Turtle() # Create alex for i in [0, 1, 2, 3]: # Draw the four sides of the square alex.forward(50) alex.left(90) wn.mainloop() Some observations:\nWhile \u0026#8220;saving some lines of code\u0026#8221; might be convenient, it is not the big deal here. What is much more important is that we\u0026#8217;ve found a \u0026#8220;repeating pattern\u0026#8221; of statements, and reorganized our program to repeat the pattern. Finding the chunks and somehow getting our programs arranged around those chunks is a vital skill in computational thinking.  The values [0, 1, 2, 3] were provided to make the loop body execute 4 times. We could have used any four values, but these are the conventional ones to use. In fact, getting a list of numbers in order is so useful that Python provides a built-in way to do this using range:\nfor i in range(4): # Executes the body with i = 0, then 1, then 2, then 3 print(\u0026#34;i = \u0026#34; + str(i)) for i in range(10): # Sets i to each of ... [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] print(\u0026#34;i = \u0026#34; + str(i))  Computer scientists like to count from 0 — this is why range(n) goes through the numbers from 0 up to n - 1.\n  Our little trick earlier to make sure that alex did the final turn to complete 360 degrees has paid off: if we had not done that, then we would not have been able to use a loop for the fourth side of the square. It would have become a “special case”, different from the other sides. When possible, we’d much prefer to make our code fit a general pattern, rather than have to create a special case.\n So to repeat something four times, a Python programmer would do this:\nfor _ in range(4):\t# here, we use _ instead of i since we don\u0026#39;t actually need the value alex.forward(50) alex.left(90) By now you should be able to see how to change our previous program so that tess can also use a for loop to draw her equilateral triangle.\nBut now, what would happen if we made the change below? Try to figure out what’s going to happen, then run the code to see if you’re right!\nimport turtle wn = turtle.Screen() # Set up the window and its attributes alex = turtle.Turtle() # Create alex for c in [\u0026#34;yellow\u0026#34;, \u0026#34;red\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;blue\u0026#34;]: alex.color(c) alex.forward(50) alex.left(90) wn.mainloop() A variable can also be assigned a value that is a list. So lists can also be used in more general situations, not only in the for loop. The code above could be rewritten like this:\nimport turtle wn = turtle.Screen() # Set up the window and its attributes alex = turtle.Turtle() # Create alex clrs = [\u0026#34;yellow\u0026#34;, \u0026#34;red\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;blue\u0026#34;] for c in clrs: alex.color(c) alex.forward(50) alex.left(90) wn.mainloop() "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_03/s06/",
	"title": "More Turtle Tricks",
	"tags": [],
	"description": "",
	"content": "No Need to Be Positive Turtle methods can use negative angles or distances. So shelly.forward(-100) will move shelly backwards, and shelly.left(-30) turns her to the right. Additionally, because there are 360 degrees in a circle, turning 30 to the left will get shelly facing in the same direction as turning 330 to the right! The on-screen animation will differ, though — you will be able to tell if shelly is turning clockwise or counter-clockwise!\nWe don’t need both a left and a right turn method — we could be minimalists, and just have one method. But, it there\u0026rsquo;s no limit on the methods a module can define and its convenient to have both so the turtle library provides both left and right turn methods, as well as forward and backward. (If you are very adventurous, you might enjoy using shelly.backward(-100) to move shelly forward!)\nPart of thinking like a computer scientist is to understand more of the structure and rich relationships in our field. So revising a few basic facts about geometry and number lines, and spotting the relationships between left, right, backward, forward, negative and positive distances or angles values is a good start.\nMoving without Drawing A turtle’s pen can be picked up or put down. This allows us to move a turtle to a different place without drawing a line. The methods are penup and pendown.\nimport ColabTurtlePlus.Turtle as turtle wn = turtle.Screen() # Set up the window and its attributes shelly = turtle.Turtle() # Create shelly shelly.penup() shelly.forward(100) # This moves shelly, but no line is drawn shelly.pendown() wn.mainloop() Squashing Turtles Every turtle can have its own shape. The shapes available are arrow, blank, circle, classic, square, triangle, turtle.\nimport ColabTurtlePlus.Turtle as turtle wn = turtle.Screen() # Creates a playground for turtles shelly = turtle.Turtle() # Create a turtle, assign to shelly shelly.shape(\u0026#34;turtle\u0026#34;) # Shape shelly to look like a turtle shelly.forward(50) # Tell shelly to move forward by 50 units shelly.left(90) # Tell shelly to turn by 90 degrees shelly.forward(30) # Complete the second side of a rectangle wn.mainloop() # Wait for user to close window Animation Part of the fun of drawing with turtles is that we don\u0026rsquo;t see the drawing appear instantly, but see the turtle move to draw. We can speed up or slow down the turtle’s speed for both turning and moving. Speed settings can be set between 1 (slowest) to 10 (fastest). But if we set the speed to 0, it has a special meaning — turn off animation and go as fast as possible.\nA turtle can “stamp” its footprint onto the canvas, and this will remain after the turtle has moved somewhere else. Stamping works, even when the pen is up.\nThe code below shows some examples using these methods:\nimport ColabTurtlePlus.Turtle as turtle wn = turtle.Screen() wn.bgcolor(\u0026#34;lightgreen\u0026#34;) shelly = turtle.Turtle() shelly.shape(\u0026#34;turtle\u0026#34;) shelly.color(\u0026#34;blue\u0026#34;) shelly.penup() size = 20 for _ in range(30): shelly.stamp() # Leave an impression on the canvas size = size + 3 # Increase the size on every iteration shelly.forward(size) # Move shelly along shelly.right(24) # ... and turn her wn.mainloop() How many times was the body of the loop executed?\nHow many turtle images are on the screen?\nAll except one of the shapes we see on the screen here are footprints created by stamp. But the program still only has one turtle object — can you figure out which one here is the real shelly? (Hint: if you’re not sure, write a new line of code after the for loop to change shelly‘ color.)\nWriting Text We can get a turtle to display text on the canvas at the turtle’s current position. The method to do that is called write:\nimport ColabTurtlePlus.Turtle as turtle wn = turtle.Screen() # Creates a playground for turtles shelly = turtle.Turtle() # Create a turtle, assign to shelly shelly.forward(50) # Tell shelly to move forward by 50 units shelly.left(90) # Tell shelly to turn by 90 degrees shelly.forward(30) # Complete the second side of a rectangle shelly.write(\u0026#34;Hi there!\u0026#34;) # Write a message wn.mainloop() # Wait for user to close window Filling Shapes We can fill a shape (circle, semicircle, triangle, etc.) with a color. It is a two-step process. First we call the method shelly.begin_fill(), then we draw the shape, then we call shelly.end_fill(). Below is an example of this using our square example from earlier.\nimport ColabTurtlePlus.Turtle as turtle wn = turtle.Screen() # Set up the window and its attributes shelly = turtle.Turtle() # Create shelly shelly.begin_fill() # Start of the region to fill for i in range(4): # Draw the four sides of the square shelly.forward(50) shelly.left(90) shelly.end_fill() # Fill the region wn.mainloop() We’ve previously set the color of our turtle — we can now also set its fill color, which need not be the same as the turtle and the pen color. We use the fillcolor method to set the turtle’s fill color:\nimport ColabTurtlePlus.Turtle as turtle wn = turtle.Screen() # Set up the window and its attributes shelly = turtle.Turtle() # Create shelly shelly.color(\u0026#34;blue\u0026#34;) # Set pen color to blue shelly.fillcolor(\u0026#34;red\u0026#34;) # Set fill color to red shelly.begin_fill() # Start of the region to fill for i in range(4): # Draw the four sides of the square shelly.forward(50) shelly.left(90) shelly.end_fill() # Fill the region wn.mainloop() "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_03/s07/",
	"title": "Drawing a Bar Graph",
	"tags": [],
	"description": "",
	"content": "Project: A Turtle Bar Chart Now we\u0026rsquo;re going to put together many of the things we\u0026rsquo;ve learned to write a program that uses a turtle to draw a bar chart.\nLet\u0026rsquo;s start with some data to be charted:\nxs = [48, 117, 200, 240, 160, 260, 220]\nCorresponding to each data measurement, we’ll draw a rectangle of that height, with a fixed width. We’re showing off a new programming concept called a function in the example below: we’re defining the function draw_bar to draw a bar of our graph. We’ll generally want to use a function to encode a complicated task that we’ll want to repeat many times (like drawing a bar in a bar graph). You can probably guess how functions work from this code, but we won\u0026rsquo;t explain it here — we\u0026rsquo;re going to discuss functions in a lot more detail in the next chapter.\nimport ColabTurtlePlus.Turtle as turtle xs = [48, 117, 200, 240, 160, 260, 220] # our data def draw_bar(t, h): \u0026quot;\u0026quot;\u0026quot; Get turtle t to draw one bar, of height h. \u0026quot;\u0026quot;\u0026quot; t.left(90) t.forward(h) # Draw up the left side t.right(90) t.forward(40) # Width of bar, along the top t.right(90) t.forward(h)\t# And down again! t.left(90) # Put the turtle facing the way we found it. t.forward(10) # Leave small gap after each bar wn = turtle.Screen() wn.bgcolor(\u0026quot;lightgreen\u0026quot;) shelly = turtle.Turtle() shelly.color(\u0026quot;blue\u0026quot;) for v in xs: # Draw a bar for each number in the data draw_bar(shelly, v) wn.mainloop() Ok, not fantasically impressive, but it is a nice start! The important thing here was the mental chunking, or how we broke the problem into smaller pieces. Our chunk is to draw one bar, and we wrote a function to do that. Then, for the whole chart, we repeatedly called our function.\nWriting Data Next, at the top of each bar, we’ll print the value of the data. We’ll do this in the body of draw_bar, by adding t.write(\u0026quot; \u0026quot; + str(height)) as the new third line of the body. We’ve put a little space in front of the number, and turned the number into a string. Without this extra space we tend to cramp our text awkwardly against the bar to the left. The result looks a lot better now:\nimport ColabTurtlePlus.Turtle as turtle xs = [48, 117, 200, 240, 160, 260, 220] # our data def draw_bar(t, height): \u0026#34;\u0026#34;\u0026#34; Get turtle t to draw one bar, of height. \u0026#34;\u0026#34;\u0026#34; t.left(90) t.forward(height) # Draw up the left side t.write(\u0026#34; \u0026#34; + str(height)) # Write the data t.right(90) t.forward(40) # Width of bar, along the top t.right(90) t.forward(height) # And down again! t.left(90) # Put the turtle facing the way we found it. t.forward(10) # Leave small gap after each bar wn = turtle.Screen() wn.bgcolor(\u0026#34;lightgreen\u0026#34;) shelly = turtle.Turtle() shelly.color(\u0026#34;blue\u0026#34;) for v in xs: # Draw a bar for each number in the data draw_bar(shelly, v) wn.mainloop() Filling the Bars And now we’ll add code to fill each bar. Our final program now looks like this:\nimport ColabTurtlePlus.Turtle as turtle xs = [48, 117, 200, 240, 160, 260, 220] # our data def draw_bar(t, height): \u0026quot;\u0026quot;\u0026quot; Get turtle t to draw one bar, of height. \u0026quot;\u0026quot;\u0026quot; t.begin_fill() # Start of the fill area t.left(90) t.forward(height) # Draw up the left side t.write(\u0026quot; \u0026quot; + str(height)) # Write the data t.right(90) t.forward(40) # Width of bar, along the top t.right(90) t.forward(height) # And down again! t.left(90) # Put the turtle facing the way we found it. t.end_fill() # Fill in the bar t.forward(10) # Leave small gap after each bar wn = turtle.Screen() wn.bgcolor(\u0026quot;lightgreen\u0026quot;) shelly = turtle.Turtle() shelly.color(\u0026quot;blue\u0026quot;) shelly.fillcolor(\u0026quot;red\u0026quot;) for v in xs: # Draw a bar for each number in the data draw_bar(shelly, v) wn.mainloop() Mmm. Perhaps the bars should not be joined to each other at the bottom. We’ll need to pick up the pen while making the gap between the bars. That is left as an exercise for you to do — you will probably also want to do something to make the bar colors more interesting!\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_04/",
	"title": "Conditionals",
	"tags": [],
	"description": "",
	"content": "Conditionals "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/chapter_05/",
	"title": "Loops and iterations",
	"tags": [],
	"description": "",
	"content": "Loops and iterations "
},
{
	"uri": "https://blueridgeboost.com/pythonbook/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "How to Think Like a Computer Scientist: Learning with Python 3 (Blue Ridge Boost Edition) Version date: September 2023\nby Blue Ridge Boost LLC, pythonbook@blueridgeboost.com\n(based on previous editions by Peter Wentworth, Jeffrey Elkner, Allen B. Downey, and Chris Meyers)\n"
},
{
	"uri": "https://blueridgeboost.com/pythonbook/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blueridgeboost.com/pythonbook/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]